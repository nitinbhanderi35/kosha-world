 been applied
	 * @param {boolean|undefined} collapseWhitespace The user-specified value for
	 * `collapseWhitespace`, without any defaulting having been applied
	 * @param {Function|undefined} normalizer The user-specified normalizer
	 * @returns {Function} A normalizer
	 */

	function makeNormalizer(_ref) {
	  let {
	    trim,
	    collapseWhitespace,
	    normalizer
	  } = _ref;
	  if (!normalizer) {
	    // No custom normalizer specified. Just use default.
	    return getDefaultNormalizer({
	      trim,
	      collapseWhitespace
	    });
	  }
	  if (typeof trim !== 'undefined' || typeof collapseWhitespace !== 'undefined') {
	    // They've also specified a value for trim or collapseWhitespace
	    throw new Error('trim and collapseWhitespace are not supported with a normalizer. ' + 'If you want to use the default trim and collapseWhitespace logic in your normalizer, ' + 'use "getDefaultNormalizer({trim, collapseWhitespace})" and compose that into your normalizer');
	  }
	  return normalizer;
	}
	function matchRegExp(matcher, text) {
	  const match = matcher.test(text);
	  if (matcher.global && matcher.lastIndex !== 0) {
	    console.warn("To match all elements we had to reset the lastIndex of the RegExp because the global flag is enabled. We encourage to remove the global flag from the RegExp.");
	    matcher.lastIndex = 0;
	  }
	  return match;
	}

	function getNodeText(node) {
	  if (node.matches('input[type=submit], input[type=button], input[type=reset]')) {
	    return node.value;
	  }
	  return Array.from(node.childNodes).filter(child => child.nodeType === TEXT_NODE && Boolean(child.textContent)).map(c => c.textContent).join('');
	}

	/**
	 * @source {https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from#Polyfill}
	 * but without thisArg (too hard to type, no need to `this`)
	 */
	var toStr$a = Object.prototype.toString;
	function isCallable$2(fn) {
	  return typeof fn === "function" || toStr$a.call(fn) === "[object Function]";
	}
	function toInteger(value) {
	  var number = Number(value);
	  if (isNaN(number)) {
	    return 0;
	  }
	  if (number === 0 || !isFinite(number)) {
	    return number;
	  }
	  return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
	}
	var maxSafeInteger = Math.pow(2, 53) - 1;
	function toLength(value) {
	  var len = toInteger(value);
	  return Math.min(Math.max(len, 0), maxSafeInteger);
	}
	/**
	 * Creates an array from an iterable object.
	 * @param iterable An iterable object to convert to an array.
	 */

	/**
	 * Creates an array from an iterable object.
	 * @param iterable An iterable object to convert to an array.
	 * @param mapfn A mapping function to call on every element of the array.
	 * @param thisArg Value of 'this' used to invoke the mapfn.
	 */
	function arrayFrom(arrayLike, mapFn) {
	  // 1. Let C be the this value.
	  // edit(@eps1lon): we're not calling it as Array.from
	  var C = Array;

	  // 2. Let items be ToObject(arrayLike).
	  var items = Object(arrayLike);

	  // 3. ReturnIfAbrupt(items).
	  if (arrayLike == null) {
	    throw new TypeError("Array.from requires an array-like object - not null or undefined");
	  }

	  // 4. If mapfn is undefined, then let mapping be false.
	  // const mapFn = arguments.length > 1 ? arguments[1] : void undefined;

	  if (typeof mapFn !== "undefined") {
	    // 5. else
	    // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
	    if (!isCallable$2(mapFn)) {
	      throw new TypeError("Array.from: when provided, the second argument must be a function");
	    }
	  }

	  // 10. Let lenValue be Get(items, "length").
	  // 11. Let len be ToLength(lenValue).
	  var len = toLength(items.length);

	  // 13. If IsConstructor(C) is true, then
	  // 13. a. Let A be the result of calling the [[Construct]] internal method
	  // of C with an argument list containing the single item len.
	  // 14. a. Else, Let A be ArrayCreate(len).
	  var A = isCallable$2(C) ? Object(new C(len)) : new Array(len);

	  // 16. Let k be 0.
	  var k = 0;
	  // 17. Repeat, while k < lenâ€¦ (also steps a - h)
	  var kValue;
	  while (k < len) {
	    kValue = items[k];
	    if (mapFn) {
	      A[k] = mapFn(kValue, k);
	    } else {
	      A[k] = kValue;
	    }
	    k += 1;
	  }
	  // 18. Let putStatus be Put(A, "length", len, true).
	  A.length = len;
	  // 20. Return A.
	  return A;
	}

	function _typeof$2(obj) {
	  "@babel/helpers - typeof";

	  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  }, _typeof$2(obj);
	}
	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}
	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
	  }
	}
	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  Object.defineProperty(Constructor, "prototype", {
	    writable: false
	  });
	  return Constructor;
	}
	function _defineProperty$2(obj, key, value) {
	  key = _toPropertyKey$1(key);
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }
	  return obj;
	}
	function _toPropertyKey$1(arg) {
	  var key = _toPrimitive$1(arg, "string");
	  return _typeof$2(key) === "symbol" ? key : String(key);
	}
	function _toPrimitive$1(input, hint) {
	  if (_typeof$2(input) !== "object" || input === null) return input;
	  var prim = input[Symbol.toPrimitive];
	  if (prim !== undefined) {
	    var res = prim.call(input, hint || "default");
	    if (_typeof$2(res) !== "object") return res;
	    throw new TypeError("@@toPrimitive must return a primitive value.");
	  }
	  return (hint === "string" ? String : Number)(input);
	}
	// for environments without Set we fallback to arrays with unique members
	var SetLike = /*#__PURE__*/function () {
	  function SetLike() {
	    var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    _classCallCheck(this, SetLike);
	    _defineProperty$2(this, "items", void 0);
	    this.items = items;
	  }
	  _createClass(SetLike, [{
	    key: "add",
	    value: function add(value) {
	      if (this.has(value) === false) {
	        this.items.push(value);
	      }
	      return this;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.items = [];
	    }
	  }, {
	    key: "delete",
	    value: function _delete(value) {
	      var previousLength = this.items.length;
	      this.items = this.items.filter(function (item) {
	        return item !== value;
	      });
	      return previousLength !== this.items.length;
	    }
	  }, {
	    key: "forEach",
	    value: function forEach(callbackfn) {
	      var _this = this;
	      this.items.forEach(function (item) {
	        callbackfn(item, item, _this);
	      });
	    }
	  }, {
	    key: "has",
	    value: function has(value) {
	      return this.items.indexOf(value) !== -1;
	    }
	  }, {
	    key: "size",
	    get: function get() {
	      return this.items.length;
	    }
	  }]);
	  return SetLike;
	}();
	var SetLike$1 = typeof Set === "undefined" ? Set : SetLike;

	// https://w3c.github.io/html-aria/#document-conformance-requirements-for-use-of-aria-attributes-in-html

	/**
	 * Safe Element.localName for all supported environments
	 * @param element
	 */
	function getLocalName(element) {
	  var _element$localName;
	  return (
	    // eslint-disable-next-line no-restricted-properties -- actual guard for environments without localName
	    (_element$localName = element.localName) !== null && _element$localName !== void 0 ? _element$localName :
	    // eslint-disable-next-line no-restricted-properties -- required for the fallback
	    element.tagName.toLowerCase()
	  );
	}
	var localNameToRoleMappings = {
	  article: "article",
	  aside: "complementary",
	  button: "button",
	  datalist: "listbox",
	  dd: "definition",
	  details: "group",
	  dialog: "dialog",
	  dt: "term",
	  fieldset: "group",
	  figure: "figure",
	  // WARNING: Only with an accessible name
	  form: "form",
	  footer: "contentinfo",
	  h1: "heading",
	  h2: "heading",
	  h3: "heading",
	  h4: "heading",
	  h5: "heading",
	  h6: "heading",
	  header: "banner",
	  hr: "separator",
	  html: "document",
	  legend: "legend",
	  li: "listitem",
	  math: "math",
	  main: "main",
	  menu: "list",
	  nav: "navigation",
	  ol: "list",
	  optgroup: "group",
	  // WARNING: Only in certain context
	  option: "option",
	  output: "status",
	  progress: "progressbar",
	  // WARNING: Only with an accessible name
	  section: "region",
	  summary: "button",
	  table: "table",
	  tbody: "rowgroup",
	  textarea: "textbox",
	  tfoot: "rowgroup",
	  // WARNING: Only in certain context
	  td: "cell",
	  th: "columnheader",
	  thead: "rowgroup",
	  tr: "row",
	  ul: "list"
	};
	var prohibitedAttributes = {
	  caption: new Set(["aria-label", "aria-labelledby"]),
	  code: new Set(["aria-label", "aria-labelledby"]),
	  deletion: new Set(["aria-label", "aria-labelledby"]),
	  emphasis: new Set(["aria-label", "aria-labelledby"]),
	  generic: new Set(["aria-label", "aria-labelledby", "aria-roledescription"]),
	  insertion: new Set(["aria-label", "aria-labelledby"]),
	  paragraph: new Set(["aria-label", "aria-labelledby"]),
	  presentation: new Set(["aria-label", "aria-labelledby"]),
	  strong: new Set(["aria-label", "aria-labelledby"]),
	  subscript: new Set(["aria-label", "aria-labelledby"]),
	  superscript: new Set(["aria-label", "aria-labelledby"])
	};

	/**
	 *
	 * @param element
	 * @param role The role used for this element. This is specified to control whether you want to use the implicit or explicit role.
	 */
	function hasGlobalAriaAttributes(element, role) {
	  // https://rawgit.com/w3c/aria/stable/#global_states
	  // commented attributes are deprecated
	  return ["aria-atomic", "aria-busy", "aria-controls", "aria-current", "aria-describedby", "aria-details",
	  // "disabled",
	  "aria-dropeffect",
	  // "errormessage",
	  "aria-flowto", "aria-grabbed",
	  // "haspopup",
	  "aria-hidden",
	  // "invalid",
	  "aria-keyshortcuts", "aria-label", "aria-labelledby", "aria-live", "aria-owns", "aria-relevant", "aria-roledescription"].some(function (attributeName) {
	    var _prohibitedAttributes;
	    return element.hasAttribute(attributeName) && !((_prohibitedAttributes = prohibitedAttributes[role]) !== null && _prohibitedAttributes !== void 0 && _prohibitedAttributes.has(attributeName));
	  });
	}
	function ignorePresentationalRole(element, implicitRole) {
	  // https://rawgit.com/w3c/aria/stable/#conflict_resolution_presentation_none
	  return hasGlobalAriaAttributes(element, implicitRole);
	}
	function getRole(element) {
	  var explicitRole = getExplicitRole(element);
	  if (explicitRole === null || explicitRole === "presentation") {
	    var implicitRole = getImplicitRole(element);
	    if (explicitRole !== "presentation" || ignorePresentationalRole(element, implicitRole || "")) {
	      return implicitRole;
	    }
	  }
	  return explicitRole;
	}
	function getImplicitRole(element) {
	  var mappedByTag = localNameToRoleMappings[getLocalName(element)];
	  if (mappedByTag !== undefined) {
	    return mappedByTag;
	  }
	  switch (getLocalName(element)) {
	    case "a":
	    case "area":
	    case "link":
	      if (element.hasAttribute("href")) {
	        return "link";
	      }
	      break;
	    case "img":
	      if (element.getAttribute("alt") === "" && !ignorePresentationalRole(element, "img")) {
	        return "presentation";
	      }
	      return "img";
	    case "input":
	      {
	        var _ref = element,
	          type = _ref.type;
	        switch (type) {
	          case "button":
	          case "image":
	          case "reset":
	          case "submit":
	            return "button";
	          case "checkbox":
	          case "radio":
	            return type;
	          case "range":
	            return "slider";
	          case "email":
	          case "tel":
	          case "text":
	          case "url":
	            if (element.hasAttribute("list")) {
	              return "combobox";
	            }
	            return "textbox";
	          case "search":
	            if (element.hasAttribute("list")) {
	              return "combobox";
	            }
	            return "searchbox";
	          case "number":
	            return "spinbutton";
	          default:
	            return null;
	        }
	      }
	    case "select":
	      if (element.hasAttribute("multiple") || element.size > 1) {
	        return "listbox";
	      }
	      return "combobox";
	  }
	  return null;
	}
	function getExplicitRole(element) {
	  var role = element.getAttribute("role");
	  if (role !== null) {
	    var explicitRole = role.trim().split(" ")[0];
	    // String.prototype.split(sep, limit) will always return an array with at least one member
	    // as long as limit is either undefined or > 0
	    if (explicitRole.length > 0) {
	      return explicitRole;
	    }
	  }
	  return null;
	}

	function isElement$1(node) {
	  return node !== null && node.nodeType === node.ELEMENT_NODE;
	}
	function isHTMLTableCaptionElement(node) {
	  return isElement$1(node) && getLocalName(node) === "caption";
	}
	function isHTMLInputElement(node) {
	  return isElement$1(node) && getLocalName(node) === "input";
	}
	function isHTMLOptGroupElement(node) {
	  return isElement$1(node) && getLocalName(node) === "optgroup";
	}
	function isHTMLSelectElement(node) {
	  return isElement$1(node) && getLocalName(node) === "select";
	}
	function isHTMLTableElement(node) {
	  return isElement$1(node) && getLocalName(node) === "table";
	}
	function isHTMLTextAreaElement(node) {
	  return isElement$1(node) && getLocalName(node) === "textarea";
	}
	function safeWindow(node) {
	  var _ref = node.ownerDocument === null ? node : node.ownerDocument,
	    defaultView = _ref.defaultView;
	  if (defaultView === null) {
	    throw new TypeError("no window available");
	  }
	  return defaultView;
	}
	function isHTMLFieldSetElement(node) {
	  return isElement$1(node) && getLocalName(node) === "fieldset";
	}
	function isHTMLLegendElement(node) {
	  return isElement$1(node) && getLocalName(node) === "legend";
	}
	function isHTMLSlotElement(node) {
	  return isElement$1(node) && getLocalName(node) === "slot";
	}
	function isSVGElement(node) {
	  return isElement$1(node) && node.ownerSVGElement !== undefined;
	}
	function isSVGSVGElement(node) {
	  return isElement$1(node) && getLocalName(node) === "svg";
	}
	function isSVGTitleElement(node) {
	  return isSVGElement(node) && getLocalName(node) === "title";
	}

	/**
	 *
	 * @param {Node} node -
	 * @param {string} attributeName -
	 * @returns {Element[]} -
	 */
	function queryIdRefs(node, attributeName) {
	  if (isElement$1(node) && node.hasAttribute(attributeName)) {
	    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- safe due to hasAttribute check
	    var ids = node.getAttribute(attributeName).split(" ");

	    // Browsers that don't support shadow DOM won't have getRootNode
	    var root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
	    return ids.map(function (id) {
	      return root.getElementById(id);
	    }).filter(function (element) {
	      return element !== null;
	    }
	    // TODO: why does this not narrow?
	    );
	  }
	  return [];
	}
	function hasAnyConcreteRoles(node, roles) {
	  if (isElement$1(node)) {
	    return roles.indexOf(getRole(node)) !== -1;
	  }
	  return false;
	}

	/**
	 * implements https://w3c.github.io/accname/
	 */

	/**
	 *  A string of characters where all carriage returns, newlines, tabs, and form-feeds are replaced with a single space, and multiple spaces are reduced to a single space. The string contains only character data; it does not contain any markup.
	 */

	/**
	 *
	 * @param {string} string -
	 * @returns {FlatString} -
	 */
	function asFlatString(s) {
	  return s.trim().replace(/\s\s+/g, " ");
	}

	/**
	 *
	 * @param node -
	 * @param options - These are not optional to prevent accidentally calling it without options in `computeAccessibleName`
	 * @returns {boolean} -
	 */
	function isHidden(node, getComputedStyleImplementation) {
	  if (!isElement$1(node)) {
	    return false;
	  }
	  if (node.hasAttribute("hidden") || node.getAttribute("aria-hidden") === "true") {
	    return true;
	  }
	  var style = getComputedStyleImplementation(node);
	  return style.getPropertyValue("display") === "none" || style.getPropertyValue("visibility") === "hidden";
	}

	/**
	 * @param {Node} node -
	 * @returns {boolean} - As defined in step 2E of https://w3c.github.io/accname/#mapping_additional_nd_te
	 */
	function isControl(node) {
	  return hasAnyConcreteRoles(node, ["button", "combobox", "listbox", "textbox"]) || hasAbstractRole(node, "range");
	}
	function hasAbstractRole(node, role) {
	  if (!isElement$1(node)) {
	    return false;
	  }
	  switch (role) {
	    case "range":
	      return hasAnyConcreteRoles(node, ["meter", "progressbar", "scrollbar", "slider", "spinbutton"]);
	    default:
	      throw new TypeError("No knowledge about abstract role '".concat(role, "'. This is likely a bug :("));
	  }
	}

	/**
	 * element.querySelectorAll but also considers owned tree
	 * @param element
	 * @param selectors
	 */
	function querySelectorAllSubtree(element, selectors) {
	  var elements = arrayFrom(element.querySelectorAll(selectors));
	  queryIdRefs(element, "aria-owns").forEach(function (root) {
	    // babel transpiles this assuming an iterator
	    elements.push.apply(elements, arrayFrom(root.querySelectorAll(selectors)));
	  });
	  return elements;
	}
	function querySelectedOptions(listbox) {
	  if (isHTMLSelectElement(listbox)) {
	    // IE11 polyfill
	    return listbox.selectedOptions || querySelectorAllSubtree(listbox, "[selected]");
	  }
	  return querySelectorAllSubtree(listbox, '[aria-selected="true"]');
	}
	function isMarkedPresentational(node) {
	  return hasAnyConcreteRoles(node, ["none", "presentation"]);
	}

	/**
	 * Elements specifically listed in html-aam
	 *
	 * We don't need this for `label` or `legend` elements.
	 * Their implicit roles already allow "naming from content".
	 *
	 * sources:
	 *
	 * - https://w3c.github.io/html-aam/#table-element
	 */
	function isNativeHostLanguageTextAlternativeElement(node) {
	  return isHTMLTableCaptionElement(node);
	}

	/**
	 * https://w3c.github.io/aria/#namefromcontent
	 */
	function allowsNameFromContent(node) {
	  return hasAnyConcreteRoles(node, ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "label", "legend", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"]);
	}

	/**
	 * TODO https://github.com/eps1lon/dom-accessibility-api/issues/100
	 */
	function isDescendantOfNativeHostLanguageTextAlternativeElement(
	// eslint-disable-next-line @typescript-eslint/no-unused-vars -- not implemented yet
	node) {
	  return false;
	}
	function getValueOfTextbox(element) {
	  if (isHTMLInputElement(element) || isHTMLTextAreaElement(element)) {
	    return element.value;
	  }
	  // https://github.com/eps1lon/dom-accessibility-api/issues/4
	  return element.textContent || "";
	}
	function getTextualContent(declaration) {
	  var content = declaration.getPropertyValue("content");
	  if (/^["'].*["']$/.test(content)) {
	    return content.slice(1, -1);
	  }
	  return "";
	}

	/**
	 * https://html.spec.whatwg.org/multipage/forms.html#category-label
	 * TODO: form-associated custom elements
	 * @param element
	 */
	function isLabelableElement(element) {
	  var localName = getLocalName(element);
	  return localName === "button" || localName === "input" && element.getAttribute("type") !== "hidden" || localName === "meter" || localName === "output" || localName === "progress" || localName === "select" || localName === "textarea";
	}

	/**
	 * > [...], then the first such descendant in tree order is the label element's labeled control.
	 * -- https://html.spec.whatwg.org/multipage/forms.html#labeled-control
	 * @param element
	 */
	function findLabelableElement(element) {
	  if (isLabelableElement(element)) {
	    return element;
	  }
	  var labelableElement = null;
	  element.childNodes.forEach(function (childNode) {
	    if (labelableElement === null && isElement$1(childNode)) {
	      var descendantLabelableElement = findLabelableElement(childNode);
	      if (descendantLabelableElement !== null) {
	        labelableElement = descendantLabelableElement;
	      }
	    }
	  });
	  return labelableElement;
	}

	/**
	 * Polyfill of HTMLLabelElement.control
	 * https://html.spec.whatwg.org/multipage/forms.html#labeled-control
	 * @param label
	 */
	function getControlOfLabel(label) {
	  if (label.control !== undefined) {
	    return label.control;
	  }
	  var htmlFor = label.getAttribute("for");
	  if (htmlFor !== null) {
	    return label.ownerDocument.getElementById(htmlFor);
	  }
	  return findLabelableElement(label);
	}

	/**
	 * Polyfill of HTMLInputElement.labels
	 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/labels
	 * @param element
	 */
	function getLabels(element) {
	  var labelsProperty = element.labels;
	  if (labelsProperty === null) {
	    return labelsProperty;
	  }
	  if (labelsProperty !== undefined) {
	    return arrayFrom(labelsProperty);
	  }

	  // polyfill
	  if (!isLabelableElement(element)) {
	    return null;
	  }
	  var document = element.ownerDocument;
	  return arrayFrom(documen