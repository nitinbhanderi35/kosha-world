ing;
	var concat = Array.prototype.concat;
	var origDefineProperty = Object.defineProperty;
	var isFunction = function (fn) {
	  return typeof fn === 'function' && toStr$7.call(fn) === '[object Function]';
	};
	var hasPropertyDescriptors = hasPropertyDescriptors_1();
	var supportsDescriptors$2 = origDefineProperty && hasPropertyDescriptors;
	var defineProperty$1 = function (object, name, value, predicate) {
	  if (name in object) {
	    if (predicate === true) {
	      if (object[name] === value) {
	        return;
	      }
	    } else if (!isFunction(predicate) || !predicate()) {
	      return;
	    }
	  }
	  if (supportsDescriptors$2) {
	    origDefineProperty(object, name, {
	      configurable: true,
	      enumerable: false,
	      value: value,
	      writable: true
	    });
	  } else {
	    object[name] = value; // eslint-disable-line no-param-reassign
	  }
	};

	var defineProperties$1 = function (object, map) {
	  var predicates = arguments.length > 2 ? arguments[2] : {};
	  var props = keys$2(map);
	  if (hasSymbols$3) {
	    props = concat.call(props, Object.getOwnPropertySymbols(map));
	  }
	  for (var i = 0; i < props.length; i += 1) {
	    defineProperty$1(object, props[i], map[props[i]], predicates[props[i]]);
	  }
	};
	defineProperties$1.supportsDescriptors = !!supportsDescriptors$2;
	var defineProperties_1 = defineProperties$1;

	var callBind$5 = {exports: {}};

	(function (module) {

	  var bind = functionBind;
	  var GetIntrinsic = getIntrinsic;
	  var $apply = GetIntrinsic('%Function.prototype.apply%');
	  var $call = GetIntrinsic('%Function.prototype.call%');
	  var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
	  var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
	  var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
	  var $max = GetIntrinsic('%Math.max%');
	  if ($defineProperty) {
	    try {
	      $defineProperty({}, 'a', {
	        value: 1
	      });
	    } catch (e) {
	      // IE 8 has a broken defineProperty
	      $defineProperty = null;
	    }
	  }
	  module.exports = function callBind(originalFunction) {
	    var func = $reflectApply(bind, $call, arguments);
	    if ($gOPD && $defineProperty) {
	      var desc = $gOPD(func, 'length');
	      if (desc.configurable) {
	        // original length, plus the receiver, minus any additional arguments (after the receiver)
	        $defineProperty(func, 'length', {
	          value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
	        });
	      }
	    }
	    return func;
	  };
	  var applyBind = function applyBind() {
	    return $reflectApply(bind, $apply, arguments);
	  };
	  if ($defineProperty) {
	    $defineProperty(module.exports, 'apply', {
	      value: applyBind
	    });
	  } else {
	    module.exports.apply = applyBind;
	  }
	})(callBind$5);

	var GetIntrinsic$7 = getIntrinsic;
	var callBind$4 = callBind$5.exports;
	var $indexOf$1 = callBind$4(GetIntrinsic$7('String.prototype.indexOf'));
	var callBound$d = function callBoundIntrinsic(name, allowMissing) {
	  var intrinsic = GetIntrinsic$7(name, !!allowMissing);
	  if (typeof intrinsic === 'function' && $indexOf$1(name, '.prototype.') > -1) {
	    return callBind$4(intrinsic);
	  }
	  return intrinsic;
	};

	// modified from https://github.com/es-shims/es6-shim
	var objectKeys$1 = objectKeys$2;
	var hasSymbols$2 = shams$1();
	var callBound$c = callBound$d;
	var toObject = Object;
	var $push = callBound$c('Array.prototype.push');
	var $propIsEnumerable = callBound$c('Object.prototype.propertyIsEnumerable');
	var originalGetSymbols = hasSymbols$2 ? Object.getOwnPropertySymbols : null;

	// eslint-disable-next-line no-unused-vars
	var implementation$8 = function assign(target, source1) {
	  if (target == null) {
	    throw new TypeError('target must be an object');
	  }
	  var to = toObject(target); // step 1
	  if (arguments.length === 1) {
	    return to; // step 2
	  }

	  for (var s = 1; s < arguments.length; ++s) {
	    var from = toObject(arguments[s]); // step 3.a.i

	    // step 3.a.ii:
	    var keys = objectKeys$1(from);
	    var getSymbols = hasSymbols$2 && (Object.getOwnPropertySymbols || originalGetSymbols);
	    if (getSymbols) {
	      var syms = getSymbols(from);
	      for (var j = 0; j < syms.length; ++j) {
	        var key = syms[j];
	        if ($propIsEnumerable(from, key)) {
	          $push(keys, key);
	        }
	      }
	    }

	    // step 3.a.iii:
	    for (var i = 0; i < keys.length; ++i) {
	      var nextKey = keys[i];
	      if ($propIsEnumerable(from, nextKey)) {
	        // step 3.a.iii.2
	        var propValue = from[nextKey]; // step 3.a.iii.2.a
	        to[nextKey] = propValue; // step 3.a.iii.2.b
	      }
	    }
	  }

	  return to; // step 4
	};

	var implementation$7 = implementation$8;
	var lacksProperEnumerationOrder = function () {
	  if (!Object.assign) {
	    return false;
	  }
	  /*
	   * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	   * note: this does not detect the bug unless there's 20 characters
	   */
	  var str = 'abcdefghijklmnopqrst';
	  var letters = str.split('');
	  var map = {};
	  for (var i = 0; i < letters.length; ++i) {
	    map[letters[i]] = letters[i];
	  }
	  var obj = Object.assign({}, map);
	  var actual = '';
	  for (var k in obj) {
	    actual += k;
	  }
	  return str !== actual;
	};
	var assignHasPendingExceptions = function () {
	  if (!Object.assign || !Object.preventExtensions) {
	    return false;
	  }
	  /*
	   * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	   * which is 72% slower than our shim, and Firefox 40's native implementation.
	   */
	  var thrower = Object.preventExtensions({
	    1: 2
	  });
	  try {
	    Object.assign(thrower, 'xy');
	  } catch (e) {
	    return thrower[1] === 'y';
	  }
	  return false;
	};
	var polyfill$4 = function getPolyfill() {
	  if (!Object.assign) {
	    return implementation$7;
	  }
	  if (lacksProperEnumerationOrder()) {
	    return implementation$7;
	  }
	  if (assignHasPendingExceptions()) {
	    return implementation$7;
	  }
	  return Object.assign;
	};

	var define$3 = defineProperties_1;
	var getPolyfill$5 = polyfill$4;
	var shim$5 = function shimAssign() {
	  var polyfill = getPolyfill$5();
	  define$3(Object, {
	    assign: polyfill
	  }, {
	    assign: function () {
	      return Object.assign !== polyfill;
	    }
	  });
	  return polyfill;
	};

	var defineProperties = defineProperties_1;
	var callBind$3 = callBind$5.exports;
	var implementation$6 = implementation$8;
	var getPolyfill$4 = polyfill$4;
	var shim$4 = shim$5;
	var polyfill$3 = callBind$3.apply(getPolyfill$4());
	// eslint-disable-next-line no-unused-vars
	var bound = function assign(target, source1) {
	  return polyfill$3(Object, arguments);
	};
	defineProperties(bound, {
	  getPolyfill: getPolyfill$4,
	  implementation: implementation$6,
	  shim: shim$4
	});
	var object_assign = bound;

	var implementation$5 = {exports: {}};

	var functionsHaveNames = function functionsHaveNames() {
	  return typeof function f() {}.name === 'string';
	};
	var gOPD$4 = Object.getOwnPropertyDescriptor;
	if (gOPD$4) {
	  try {
	    gOPD$4([], 'length');
	  } catch (e) {
	    // IE 8 has a broken gOPD
	    gOPD$4 = null;
	  }
	}
	functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
	  if (!functionsHaveNames() || !gOPD$4) {
	    return false;
	  }
	  var desc = gOPD$4(function () {}, 'name');
	  return !!desc && !!desc.configurable;
	};
	var $bind = Function.prototype.bind;
	functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
	  return functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';
	};
	var functionsHaveNames_1 = functionsHaveNames;

	(function (module) {

	  var functionsHaveConfigurableNames = functionsHaveNames_1.functionsHaveConfigurableNames();
	  var $Object = Object;
	  var $TypeError = TypeError;
	  module.exports = function flags() {
	    if (this != null && this !== $Object(this)) {
	      throw new $TypeError('RegExp.prototype.flags getter called on non-object');
	    }
	    var result = '';
	    if (this.hasIndices) {
	      result += 'd';
	    }
	    if (this.global) {
	      result += 'g';
	    }
	    if (this.ignoreCase) {
	      result += 'i';
	    }
	    if (this.multiline) {
	      result += 'm';
	    }
	    if (this.dotAll) {
	      result += 's';
	    }
	    if (this.unicode) {
	      result += 'u';
	    }
	    if (this.unicodeSets) {
	      result += 'v';
	    }
	    if (this.sticky) {
	      result += 'y';
	    }
	    return result;
	  };
	  if (functionsHaveConfigurableNames && Object.defineProperty) {
	    Object.defineProperty(module.exports, 'name', {
	      value: 'get flags'
	    });
	  }
	})(implementation$5);

	var implementation$4 = implementation$5.exports;
	var supportsDescriptors$1 = defineProperties_1.supportsDescriptors;
	var $gOPD$1 = Object.getOwnPropertyDescriptor;
	var polyfill$2 = function getPolyfill() {
	  if (supportsDescriptors$1 && /a/mig.flags === 'gim') {
	    var descriptor = $gOPD$1(RegExp.prototype, 'flags');
	    if (descriptor && typeof descriptor.get === 'function' && typeof RegExp.prototype.dotAll === 'boolean' && typeof RegExp.prototype.hasIndices === 'boolean') {
	      /* eslint getter-return: 0 */
	      var calls = '';
	      var o = {};
	      Object.defineProperty(o, 'hasIndices', {
	        get: function () {
	          calls += 'd';
	        }
	      });
	      Object.defineProperty(o, 'sticky', {
	        get: function () {
	          calls += 'y';
	        }
	      });
	      if (calls === 'dy') {
	        return descriptor.get;
	      }
	    }
	  }
	  return implementation$4;
	};

	var supportsDescriptors = defineProperties_1.supportsDescriptors;
	var getPolyfill$3 = polyfill$2;
	var gOPD$3 = Object.getOwnPropertyDescriptor;
	var defineProperty = Object.defineProperty;
	var TypeErr = TypeError;
	var getProto = Object.getPrototypeOf;
	var regex = /a/;
	var shim$3 = function shimFlags() {
	  if (!supportsDescriptors || !getProto) {
	    throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
	  }
	  var polyfill = getPolyfill$3();
	  var proto = getProto(regex);
	  var descriptor = gOPD$3(proto, 'flags');
	  if (!descriptor || descriptor.get !== polyfill) {
	    defineProperty(proto, 'flags', {
	      configurable: true,
	      enumerable: false,
	      get: polyfill
	    });
	  }
	  return polyfill;
	};

	var define$2 = defineProperties_1;
	var callBind$2 = callBind$5.exports;
	var implementation$3 = implementation$5.exports;
	var getPolyfill$2 = polyfill$2;
	var shim$2 = shim$3;
	var flagsBound = callBind$2(getPolyfill$2());
	define$2(flagsBound, {
	  getPolyfill: getPolyfill$2,
	  implementation: implementation$3,
	  shim: shim$2
	});
	var regexp_prototype_flags = flagsBound;

	var esGetIterator = {exports: {}};

	var hasSymbols$1 = shams$1;
	var shams = function hasToStringTagShams() {
	  return hasSymbols$1() && !!Symbol.toStringTag;
	};

	var hasToStringTag$8 = shams();
	var callBound$b = callBound$d;
	var $toString$4 = callBound$b('Object.prototype.toString');
	var isStandardArguments = function isArguments(value) {
	  if (hasToStringTag$8 && value && typeof value === 'object' && Symbol.toStringTag in value) {
	    return false;
	  }
	  return $toString$4(value) === '[object Arguments]';
	};
	var isLegacyArguments = function isArguments(value) {
	  if (isStandardArguments(value)) {
	    return true;
	  }
	  return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString$4(value) !== '[object Array]' && $toString$4(value.callee) === '[object Function]';
	};
	var supportsStandardArguments = function () {
	  return isStandardArguments(arguments);
	}();
	isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

	var isArguments$2 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': _nodeResolve_empty
	});

	var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

	var hasMap = typeof Map === 'function' && Map.prototype;
	var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
	var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
	var mapForEach = hasMap && Map.prototype.forEach;
	var hasSet = typeof Set === 'function' && Set.prototype;
	var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
	var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
	var setForEach = hasSet && Set.prototype.forEach;
	var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
	var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
	var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
	var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
	var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
	var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
	var booleanValueOf = Boolean.prototype.valueOf;
	var objectToString = Object.prototype.toString;
	var functionToString = Function.prototype.toString;
	var $match = String.prototype.match;
	var $slice$2 = String.prototype.slice;
	var $replace = String.prototype.replace;
	var $toUpperCase = String.prototype.toUpperCase;
	var $toLowerCase = String.prototype.toLowerCase;
	var $test = RegExp.prototype.test;
	var $concat = Array.prototype.concat;
	var $join = Array.prototype.join;
	var $arrSlice = Array.prototype.slice;
	var $floor = Math.floor;
	var bigIntValueOf$1 = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
	var gOPS = Object.getOwnPropertySymbols;
	var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
	var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';
	// ie, `has-tostringtag/shams
	var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var gPO$1 = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
	? function (O) {
	  return O.__proto__; // eslint-disable-line no-proto
	} : null);
	function addNumericSeparator(num, str) {
	  if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
	    return str;
	  }
	  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
	  if (typeof num === 'number') {
	    var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
	    if (int !== num) {
	      var intStr = String(int);
	      var dec = $slice$2.call(str, intStr.length + 1);
	      return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
	    }
	  }
	  return $replace.call(str, sepRegex, '$&_');
	}
	var utilInspect = require$$0;
	var inspectCustom = utilInspect.custom;
	var inspectSymbol = isSymbol$2(inspectCustom) ? inspectCustom : null;
	var objectInspect = function inspect_(obj, options, depth, seen) {
	  var opts = options || {};
	  if (has$2(opts, 'quoteStyle') && opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double') {
	    throw new TypeError('option "quoteStyle" must be "single" or "double"');
	  }
	  if (has$2(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
	    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
	  }
	  var customInspect = has$2(opts, 'customInspect') ? opts.customInspect : true;
	  if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
	    throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
	  }
	  if (has$2(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
	    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
	  