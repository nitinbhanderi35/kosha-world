& nodeMinor >= 13\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/fetch/constants.js\nvar require_constants = __commonJS({\n  "../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/fetch/constants.js"(exports, module2) {\n    "use strict";\n    init_define_process();\n    var { MessageChannel, receiveMessageOnPort } = require("worker_threads");\n    var corsSafeListedMethods = ["GET", "HEAD", "POST"];\n    var nullBodyStatus = [101, 204, 205, 304];\n    var redirectStatus = [301, 302, 303, 307, 308];\n    var badPorts = [\n      "1",\n      "7",\n      "9",\n      "11",\n      "13",\n      "15",\n      "17",\n      "19",\n      "20",\n      "21",\n      "22",\n      "23",\n      "25",\n      "37",\n      "42",\n      "43",\n      "53",\n      "69",\n      "77",\n      "79",\n      "87",\n      "95",\n      "101",\n      "102",\n      "103",\n      "104",\n      "109",\n      "110",\n      "111",\n      "113",\n      "115",\n      "117",\n      "119",\n      "123",\n      "135",\n      "137",\n      "139",\n      "143",\n      "161",\n      "179",\n      "389",\n      "427",\n      "465",\n      "512",\n      "513",\n      "514",\n      "515",\n      "526",\n      "530",\n      "531",\n      "532",\n      "540",\n      "548",\n      "554",\n      "556",\n      "563",\n      "587",\n      "601",\n      "636",\n      "989",\n      "990",\n      "993",\n      "995",\n      "1719",\n      "1720",\n      "1723",\n      "2049",\n      "3659",\n      "4045",\n      "5060",\n      "5061",\n      "6000",\n      "6566",\n      "6665",\n      "6666",\n      "6667",\n      "6668",\n      "6669",\n      "6697",\n      "10080"\n    ];\n    var referrerPolicy = [\n      "",\n      "no-referrer",\n      "no-referrer-when-downgrade",\n      "same-origin",\n      "origin",\n      "strict-origin",\n      "origin-when-cross-origin",\n      "strict-origin-when-cross-origin",\n      "unsafe-url"\n    ];\n    var requestRedirect = ["follow", "manual", "error"];\n    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];\n    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];\n    var requestCredentials = ["omit", "same-origin", "include"];\n    var requestCache = [\n      "default",\n      "no-store",\n      "reload",\n      "no-cache",\n      "force-cache",\n      "only-if-cached"\n    ];\n    var requestBodyHeader = [\n      "content-encoding",\n      "content-language",\n      "content-location",\n      "content-type",\n      // See https://github.com/nodejs/undici/issues/2021\n      // \'Content-Length\' is a forbidden header name, which is typically\n      // removed in the Headers implementation. However, undici doesn\'t\n      // filter out headers, so we add it here.\n      "content-length"\n    ];\n    var requestDuplex = [\n      "half"\n    ];\n    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];\n    var subresource = [\n      "audio",\n      "audioworklet",\n      "font",\n      "image",\n      "manifest",\n      "paintworklet",\n      "script",\n      "style",\n      "track",\n      "video",\n      "xslt",\n      ""\n    ];\n    var DOMException = globalThis.DOMException ?? (() => {\n      try {\n        atob("~");\n      } catch (err) {\n        return Object.getPrototypeOf(err).constructor;\n      }\n    })();\n    var channel;\n    var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js\n    // structuredClone was added in v17.0.0, but fetch supports v16.8\n    /* @__PURE__ */ __name(function structuredClone2(value, options = void 0) {\n      if (arguments.length === 0) {\n        throw new TypeError("missing argument");\n      }\n      if (!channel) {\n        channel = new MessageChannel();\n      }\n      channel.port1.unref();\n      channel.port2.unref();\n      channel.port1.postMessage(value, options?.transfer);\n      return receiveMessageOnPort(channel.port2).message;\n    }, "structuredClone");\n    module2.exports = {\n      DOMException,\n      structuredClone,\n      subresource,\n      forbiddenMethods,\n      requestBodyHeader,\n      referrerPolicy,\n      requestRedirect,\n      requestMode,\n      requestCredentials,\n      requestCache,\n      redirectStatus,\n      corsSafeListedMethods,\n      nullBodyStatus,\n      safeMethods,\n      badPorts,\n      requestDuplex\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/fetch/global.js\nvar require_global = __commonJS({\n  "../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/fetch/global.js"(exports, module2) {\n    "use strict";\n    init_define_process();\n    var globalOrigin = Symbol.for("undici.globalOrigin.1");\n    function getGlobalOrigin() {\n      return globalThis[globalOrigin];\n    }\n    __name(getGlobalOrigin, "getGlobalOrigin");\n    function setGlobalOrigin(newOrigin) {\n      if (newOrigin !== void 0 && typeof newOrigin !== "string" && !(newOrigin instanceof URL)) {\n        throw new Error("Invalid base url");\n      }\n      if (newOrigin === void 0) {\n        Object.defineProperty(globalThis, globalOrigin, {\n          value: void 0,\n          writable: true,\n          enumerable: false,\n          configurable: false\n        });\n        return;\n      }\n      const parsedURL = new URL(newOrigin);\n      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {\n        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);\n      }\n      Object.defineProperty(globalThis, globalOrigin, {\n        value: parsedURL,\n        writable: true,\n        enumerable: false,\n        configurable: false\n      });\n    }\n    __name(setGlobalOrigin, "setGlobalOrigin");\n    module2.exports = {\n      getGlobalOrigin,\n      setGlobalOrigin\n    };\n  }\n});\n\n// src/patches/util-types.js\nvar require_util_types = __commonJS({\n  "src/patches/util-types.js"(exports, module2) {\n    "use strict";\n    init_define_process();\n    module2.exports = require("util").types;\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/fetch/util.js\nvar require_util2 = __commonJS({\n  "../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/fetch/util.js"(exports, module2) {\n    "use strict";\n    init_define_process();\n    var { redirectStatus, badPorts, referrerPolicy: referrerPolicyTokens } = require_constants();\n    var { getGlobalOrigin } = require_global();\n    var { performance: performance2 } = require("perf_hooks");\n    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();\n    var assert = require("assert");\n    var { isUint8Array } = require_util_types();\n    var crypto;\n    try {\n      crypto = require("crypto");\n    } catch {\n    }\n    function responseURL(response) {\n      const urlList = response.urlList;\n      const length = urlList.length;\n      return length === 0 ? null : urlList[length - 1].toString();\n    }\n    __name(responseURL, "responseURL");\n    function responseLocationURL(response, requestFragment) {\n      if (!redirectStatus.includes(response.status)) {\n        return null;\n      }\n      let location = response.headersList.get("location");\n      if (location !== null && isValidHeaderValue(location)) {\n        location = new URL(location, responseURL(response));\n      }\n      if (location && !location.hash) {\n        location.hash = requestFragment;\n      }\n      return location;\n    }\n    __name(responseLocationURL, "responseLocationURL");\n    function requestCurrentURL(request) {\n      return request.urlList[request.urlList.length - 1];\n    }\n    __name(requestCurrentURL, "requestCurrentURL");\n    function requestBadPort(request) {\n      const url = requestCurrentURL(request);\n      if (urlIsHttpHttpsScheme(url) && badPorts.includes(url.port)) {\n        return "blocked";\n      }\n      return "allowed";\n    }\n    __name(requestBadPort, "requestBadPort");\n    function isErrorLike(object) {\n      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");\n    }\n    __name(isErrorLike, "isErrorLike");\n    function isValidReasonPhrase(statusText) {\n      for (let i = 0; i < statusText.length; ++i) {\n        const c = statusText.charCodeAt(i);\n        if (!(c === 9 || // HTAB\n        c >= 32 && c <= 126 || // SP / VCHAR\n        c >= 128 && c <= 255)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(isValidReasonPhrase, "isValidReasonPhrase");\n    function isTokenChar(c) {\n      return !(c >= 127 || c <= 32 || c === "(" || c === ")" || c === "<" || c === ">" || c === "@" || c === "," || c === ";" || c === ":" || c === "\\\\" || c === \'"\' || c === "/" || c === "[" || c === "]" || c === "?" || c === "=" || c === "{" || c === "}");\n    }\n    __name(isTokenChar, "isTokenChar");\n    function isValidHTTPToken(characters) {\n      if (!characters || typeof characters !== "string") {\n        return false;\n      }\n      for (let i = 0; i < characters.length; ++i) {\n        const c = characters.charCodeAt(i);\n        if (c > 127 || !isTokenChar(c)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    __name(isValidHTTPToken, "isValidHTTPToken");\n    function isValidHeaderName2(potentialValue) {\n      if (potentialValue.length === 0) {\n        return false;\n      }\n      return isValidHTTPToken(potentialValue);\n    }\n    __name(isValidHeaderName2, "isValidHeaderName");\n    function isValidHeaderValue(potentialValue) {\n      if (potentialValue.startsWith("\t") || potentialValue.startsWith(" ") || potentialValue.endsWith("\t") || potentialValue.endsWith(" ")) {\n        return false;\n      }\n      if (potentialValue.includes("\\0") || potentialValue.includes("\\r") || potentialValue.includes("\\n")) {\n        return false;\n      }\n      return true;\n    }\n    __name(isValidHeaderValue, "isValidHeaderValue");\n    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n      const { headersList } = actualResponse;\n      const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");\n      let policy = "";\n      if (policyHeader.length > 0) {\n        for (let i = policyHeader.length; i !== 0; i--) {\n          const token = policyHeader[i - 1].trim();\n          if (referrerPolicyTokens.includes(token)) {\n            policy = token;\n            break;\n          }\n        }\n      }\n      if (policy !== "") {\n        request.referrerPolicy = policy;\n      }\n    }\n    __name(setRequestReferrerPolicyOnRedirect, "setRequestReferrerPolicyOnRedirect");\n    function crossOriginResourcePolicyCheck() {\n      return "allowed";\n    }\n    __name(crossOriginResourcePolicyCheck, "crossOriginResourcePolicyCheck");\n    function corsCheck() {\n      return "success";\n    }\n    __name(corsCheck, "corsCheck");\n    function TAOCheck() {\n      return "success";\n    }\n    __name(TAOCheck, "TAOCheck");\n    function appendFetchMetadata(httpRequest) {\n      let header = null;\n      header = httpRequest.mode;\n      httpRequest.headersList.set("sec-fetch-mode", header);\n    }\n    __name(appendFetchMetadata, "appendFetchMetadata");\n    function appendRequestOriginHeader(request) {\n      let serializedOrigin = request.origin;\n      if (request.responseTainting === "cors" || request.mode === "websocket") {\n        if (serializedOrigin) {\n          request.headersList.append("origin", serializedOrigin);\n        }\n      } else if (request.method !== "GET" && request.method !== "HEAD") {\n        switch (request.referrerPolicy) {\n          case "no-referrer":\n            serializedOrigin = null;\n            break;\n          case "no-referrer-when-downgrade":\n          case "strict-origin":\n          case "strict-origin-when-cross-origin":\n            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n              serializedOrigin = null;\n            }\n            break;\n          case "same-origin":\n            if (!sameOrigin(request, requestCurrentURL(request))) {\n              serializedOrigin = null;\n            }\n            break;\n          default:\n        }\n        if (serializedOrigin) {\n          request.headersList.append("origin", serializedOrigin);\n        }\n      }\n    }\n    __name(appendRequestOriginHeader, "appendRequestOriginHeader");\n    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n      return performance2.now();\n    }\n    __name(coarsenedSharedCurrentTime, "coarsenedSharedCurrentTime");\n    function createOpaqueTimingInfo(timingInfo) {\n      return {\n        startTime: timingInfo.startTime ?? 0,\n        redirectStartTime: 0,\n        redirectEndTime: 0,\n        postRedirectStartTime: timingInfo.startTime ?? 0,\n        finalServiceWorkerStartTime: 0,\n        finalNetworkResponseStartTime: 0,\n        finalNetworkRequestStartTime: 0,\n        endTime: 0,\n        encodedBodySize: 0,\n        decodedBodySize: 0,\n        finalConnectionTimingInfo: null\n      };\n    }\n    __name(createOpaqueTimingInfo, "createOpaqueTimingInfo");\n    function makePolicyContainer() {\n      return {\n        referrerPolicy: "strict-origin-when-cross-origin"\n      };\n    }\n    __name(makePolicyContainer, "makePolicyContainer");\n    function clonePolicyContainer(policyContainer) {\n      return {\n        referrerPolicy: policyContainer.referrerPolicy\n      };\n    }\n    __name(clonePolicyContainer, "clonePolicyContainer");\n    function determineRequestsReferrer(request) {\n      const policy = request.referrerPolicy;\n      assert(policy);\n      let referrerSource = null;\n      if (request.referrer === "client") {\n        const globalOrigin = getGlobalOrigin();\n        if (!globalOrigin || globalOrigin.origin === "null") {\n          return "no-referrer";\n        }\n        referrerSource = new URL(globalOrigin);\n      } else if (request.referrer instanceof URL) {\n        referrerSource = request.referrer;\n      }\n      let referrerURL = stripURLForReferrer(referrerSource);\n      const referrerOrigin = stripURLForReferrer(referrerSource, true);\n      if (referrerURL.toString().length > 4096) {\n        referrerURL = referrerOrigin;\n      }\n      const areSameOrigin = sameOrigin(request, referrerURL);\n      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);\n      switch (policy) {\n        case "origin":\n          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n        case "unsafe-url":\n          return referrerURL;\n        case "same-origin":\n          return areSameOrigin ? referrerOrigin : "no-referrer";\n        case "origin-when-cross-origin":\n          return areSameOrigin ? referrerURL : referrerOrigin;\n        case "strict-origin-when-cross-origin": {\n          const currentURL = requestCurrentURL(request);\n          if (sameOrigin(referrerURL, currentURL)) {\n            return referrerURL;\n          }\n          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n            return "no-referrer";\n          }\n          return referrerOrigin;\n        }\n        case "strict-origin":\n        case "no-referrer-when-downgrade":\n        default:\n          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;\n      }\n    }\n    __name(determineRequestsReferrer, "determineRequestsReferrer");\n    function stripURLForReferrer(url, originOnly) {\n      assert(url instanceof URL);\n      if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {\n        return "no-referrer";\n      }\n      url.username = "";\n      url.password = "";\n      url.hash = "";\n      if (originOnly) {\n        url.pathname = "";\n        url.search = "";\n      }\n      return url;\n    }\n    __name(stripURLForReferrer, "stripURLForReferrer");\n    function isURLPotentiallyTrustworthy(url) {\n      if (!(url instanceof URL)) {\n        return false;\n      }\n      if (url.href === "about:blank" || url.href === "about:srcdoc") {\n        return true;\n      }\n      if (url.protocol === "data:")\n        return true;\n      if (url.protocol === "file:")\n        return true;\n      return isOriginPotentiallyTrustworthy(url.origin);\n      function isOriginPotentiallyTrustworthy(origin) {\n        if (origin == null || origin === "null")\n          return false;\n        const originAsURL = new URL(origin);\n        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {\n          return true;\n        }\n        if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {\n          return true;\n        }\n        return false;\n      }\n      __name(isOriginPotentiallyTrustworthy, "isOriginPotentiallyTrustworthy");\n    }\n    __name(isURLPotentiallyTrustworthy, "isURLPotentiallyTrustworthy");\n    function bytesMatch(bytes, metadataList) {\n      if (crypto === void 0) {\n        return true;\n      }\n      const parsedMetadata = parseMetadata(metadataList);\n      if (parsedMetadata === "no metadata") {\n        return true;\n      }\n      if (parsedMetadata.length === 0) {\n        return true;\n      }\n      const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));\n      const strongest = list[0].algo;\n      const metadata = list.filter((item) => item.algo === strongest);\n      for (const item of metadata) {\n        const algorithm = item.algo;\n        const expectedValue = item.hash;\n        const actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");\n        if (actualValue === expectedValue) {\n          return true;\n        }\n      }\n      return false;\n    }\n    __name(bytesMatch, "bytesMatch");\n    var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i;\n    function parseMetadata(metadata) {\n      const result = [];\n      let empty = true;\n      const supportedHashes = crypto.getHashes();\n      for (const token of metadata.split(" ")) {\n        empty = false;\n        const parsedToken = parseHashWithOptions.exec(token);\n        if (parsedToken === null || parsedToken.groups === void 0) {\n          continue;\n        }\n        const algorithm = parsedToken.groups.algo;\n        if (supportedHashes.includes(algorithm.toLowerCase())) {\n          result.push(parsedToken.groups);\n        }\n      }\n      if (empty === true) {\n        return "no metadata";\n      }\n      return result;\n    }\n    __name(parseMetadata, "parseMetadata");\n    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n    }\n    __name(tryUpgradeRequestToAPotentiallyTrustworthyURL, "tryUpgradeRequestToAPotentiallyTrustworthyURL");\n    function sameOrigin(A, B) {\n      if (A.origin === B.origin && A.origin === "null") {\n        return true;\n      }\n      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n        return true;\n      }\n      return false;\n    }\n    __name(sameOrigin, "sameOrigin");\n    function createDeferredPromise() {\n      let res;\n      let rej;\n      const promise = new Promise((resolve, reject) => {\n        res = resolve;\n        rej = reject;\n      });\n      return { promise, resolve: res, reject: rej };\n    }\n    __name(createDeferredPromise, "createDeferredPromise");\n    function isAborted(fetchParams) {\n      return fetchParams.controller.state === "aborted";\n    }\n    __name(isAborted, "isAborted");\n    function isCancelled(fetchParams) {\n      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";\n    }\n    __name(isCancelled, "isCancelled");\n    function normalizeMethod(method) {\n      return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;\n    }\n    __name(normalizeMethod, "normalizeMethod");\n    function serializeJavascriptValueToJSONString(value) {\n      const result = JSON.stringify(value);\n      if (result === void 0) {\n        throw new TypeError("Value is not JSON serializable");\n      }\n      assert(typeof result === "string");\n      return result;\n    }\n    __name(serializeJavascriptValueToJSONString, "serializeJavascriptValueToJSONString");\n    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n    function makeIterator(iterator, name, kind) {\n      const object = {\n        index: 0,\n        kind,\n        target: iterator\n      };\n      const i = {\n        next() {\n          if (Object.getPrototypeOf(this) !== i) {\n            throw new TypeError(\n              `\'next\' called on an object that does not implement interface ${name} Iterator.`\n            );\n          }\n          const { index, kind: kind2, target } = object;\n          const values = target();\n          const len = values.length;\n          if (index >= len) {\n            return { value: void 0, done: true };\n          }\n          const pair = values[index];\n          object.index = index + 1;\n          return iteratorResult(pair, kind2);\n        },\n        // The class string of an iterator prototype object for a given interface is the\n        // result of concatenating the identifier of the interface and the string " Iterator".\n        [Symbol.toStringTag]: `${name} Iterator`\n      };\n      Object.setPrototypeOf(i, esIteratorPrototype);\n      return Object.setPrototypeOf({}, i);\n    }\n    __name(makeIterator, "makeIterator");\n    function iteratorResult(pair, kind) {\n      let result;\n      switch (kind) {\n        case "key": {\n          result = pair[0];\n          break;\n        }\n        case "value": {\n          result = pair[1];\n          break;\n        }\n        case "key+value": {\n          result = pair;\n          break;\n        }\n      }\n      return { value: result, done: false };\n    }\n    __name(iteratorResult, "iteratorResult");\n    function fullyReadBody(body, processBody, processBodyError) {\n      const successSteps = /* @__PURE__ */ __name((bytes) => queueMicrotask(() => processBody(bytes)), "successSteps");\n      const errorSteps = /* @__PURE__ */ __name((error) => queueMicrotask(() => processBodyError(error)), "errorSteps");\n      let reader;\n      try {\n        reader = body.stream.getReader();\n      } catch (e) {\n        errorSteps(e);\n        return;\n      }\n      readAllBytes(reader, successSteps, errorSteps);\n    }\n    __name(fullyReadBody, "fullyReadBody");\n    var ReadableStream = globalThis.ReadableStream;\n    function isReadableStreamLike(stream) {\n      if (!ReadableStream) {\n        ReadableStream = require("./streams").ReadableStream;\n      }\n      return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";\n    }\n    __name(isReadableStreamLike, "isReadableStreamLike");\n    var MAXIMUM_ARGUMENT_LENGTH = 65535;\n    function isomorphicDecode(input) {\n      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n        return String.fromCharCode(...input);\n      }\n      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");\n    }\n    __name(isomorphicDecode, "isomorphicDecode");\n    function readableStreamClose(controller) {\n      try {\n        controller.close();\n      } catch (err) {\n        if (!err.message.includes("Controller is already closed")) {\n          throw err;\n        }\n      }\n    }\n    __name(readableStreamClose, "readableStreamClose");\n    function isomorphicEncode(input) {\n      for (let i = 0; i < input.length; i++) {\n        assert(input.charCodeAt(i) <= 255);\n      }\n      return input;\n    }\n    __name(isomorphicEncode, "isomorphicEncode");\n    async function readAllBytes(reader, successSteps, failureSteps) {\n      const bytes = [];\n      let byteLength = 0;\n      while (true) {\n        let done;\n        let chunk;\n        try {\n          ({ done, value: chunk } = await reader.read());\n        } catch (e) {\n          failureSteps(e);\n          return;\n        }\n        if (done) {\n          successSteps(Buffer.concat(bytes, byteLength));\n          return;\n        }\n        if (!isUint8Array(chunk)) {\n          failureSteps(new TypeError("Received non-Uint8Array chunk"));\n          return;\n        }\n        bytes.push(chunk);\n        byteLength += chunk.length;\n      }\n    }\n    __name(readAllBytes, "readAllBytes");\n    function urlIsLocal(url) {\n      assert("protocol" in url);\n      const protocol = url.protocol;\n      return protocol === "about:" || protocol === "blob:" || protocol === "data:";\n    }\n    __name(urlIsLocal, "urlIsLocal");\n    function urlHasHttpsScheme(url) {\n      if (typeof url === "string") {\n        return url.startsWith("https:");\n      }\n      return url.protocol === "https:";\n    }\n    __name(urlHasHttpsScheme, "urlHasHttpsScheme");\n    function urlIsHttpHttpsScheme(url) {\n      assert("protocol" in url);\n      const protocol = url.protocol;\n      return protocol === "http:" || protocol === "https:";\n    }\n    __name(urlIsHttpHttpsScheme, "urlIsHttpHttpsScheme");\n    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));\n    module2.exports = {\n      isAborted,\n      isCancelled,\n      createDeferredPromise,\n      ReadableStreamFrom,\n      toUSVString,\n      tryUpgradeRequestToAPotentiallyTrustworthyURL,\n      coarsenedSharedCurrentTime,\n      determineRequestsReferrer,\n      makePolicyContainer,\n      clonePolicyContainer,\n      appendFetchMetadata,\n      appendRequestOriginHeader,\n      TAOCheck,\n      corsCheck,\n      crossOriginResourcePolicyCheck,\n      createOpaqueTimingInfo,\n      setRequestReferrerPolicyOnRedirect,\n      isValidHTTPToken,\n      requestBadPort,\n      requestCurrentURL,\n      responseURL,\n      responseLocationURL,\n      isBlobLike,\n      isURLPotentiallyTrustworthy,\n      isValidReasonPhrase,\n      sameOrigin,\n      normalizeMethod,\n      serializeJavascriptValueToJSONString,\n      makeIterator,\n      isValidHeaderName: isValidHeaderName2,\n      isValidHeaderValue,\n      hasOwn,\n      isErrorLike,\n      fullyReadBody,\n      bytesMatch,\n      isReadableStreamLike,\n      readableStreamClose,\n      isomorphicEncode,\n      isomorphicDecode,\n      urlIsLocal,\n      urlHasHttpsScheme,\n      urlIsHttpHttpsScheme,\n      readAllBytes\n    };\n  }\n});\n\n// ../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/fetch/webidl.js\nvar require_webidl = __commonJS({\n  "../../node_modules/.pnpm/undici@5.23.0/node_modules/undici/lib/fetch/webidl.js"(exports, module2) {\n    "use strict";\n    init_define_process();\n    var { types } = require("util");\n    var { hasOwn, toUSVString } = require_util2();\n    var webidl = {};\n    webidl.converters = {};\n    webidl.util = {};\n    webidl.errors = {};\n    webidl.errors.exception = function(message) {\n      return new TypeError(`${message.header}: ${message.message}`);\n    };\n    webidl.errors.conversionFailed = function(context) {\n      const plural = context.types.length === 1 ? "" : " one of";\n      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;\n      return webidl.errors.exception({\n        header: context.prefix,\n        message\n      });\n    };\n    webidl.errors.invalidArgument = function(context) {\n      return webidl.errors.exception({\n        header: context.prefix,\n        message: `"${context.value}" is an invalid ${context.type}.`\n      });\n    };\n    webidl.brandCheck = function(V, I, opts = void 0) {\n      if (opts?.strict !== false && !(V instanceof I)) {\n        throw new TypeError("Illegal invocation");\n      } else {\n        return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];\n      }\n    };\n    webidl.argumentLengthCheck = function({ length }, min, ctx) {\n      if (length < min) {\n        throw webidl.errors.exception({\n          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,\n          ...ctx\n        });\n      }\n    };\n    webidl.illegalConstructor = function() {\n      throw webidl.errors.exception({\n        header: "TypeError",\n        message: "Illegal constructor"\n      });\n    };\n    webidl.util.Type = function(V) {\n      switch (typeof V) {\n        case "undefined":\n          return "Undefined";\n        case "boolean":\n          return "Boolean";\n        case "string":\n          return "String";\n        case "symbol":\n          return "Symbol";\n        case "number":\n          return "Number";\n        case "bigint":\n          return "BigInt";\n        case "function":\n        case "object": {\n          if (V === null) {\n            return "Null";\n          }\n          return "Object";\n        }\n      }\n    };\n    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {\n      let upperBound;\n      let lowerBound;\n      if (bitLength === 64) {\n        upperBound = Math.pow(2, 53) - 1;\n        if (signedness === "unsigned") {\n          lowerBound = 0;\n        } else {\n          lowerBound = Math.pow(-2, 53) + 1;\n        }\n      } else if (signedness === "unsigned") {\n        lowerBound = 0;\n        upperBound = Math.pow(2, bitLength) - 1;\n      } else {\n        lowerBound = Math.pow(-2, bitLength) - 1;\n        upperBound = Math.pow(2, bitLength - 1) - 1;\n      }\n      let x = Number(V);\n      if (x === 0) {\n        x = 0;\n      }\n      if (opts.enforceRange === true) {\n        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n          throw webidl.errors.exception({\n            header: "Integer conversion",\n            message: `Could not convert ${V} to an integer.`\n          });\n        }\n        x = webidl.util.IntegerPart(x);\n        if (x < lowerBound || x > upperBound) {\n          throw webidl.errors.exception({\n            header: "Integer conversion",\n            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n          });\n        }\n        return x;\n      }\n      if (!Number.isNaN(x) && opts.clamp === true) {\n        x = Math.min(Math.max(x, lowerBound), upperBound);\n        if (Math.floor(x) % 2 === 0) {\n          x = Math.floor(x);\n        } else {\n          x = Math.ceil(x);\n        }\n        return x;\n      }\n      if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {\n        return 0;\n      }\n      x = webidl.util.IntegerPart(x);\n      x = x % Math.pow(2, bitLength);\n      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {\n        return x - Math.pow(2, bitLength);\n      }\n      return x;\n    };\n    webidl.util.IntegerPart = function(n) {\n      const r = Math.floor(Math.abs(n));\n      if (n < 0) {\n        return -1 * r;\n      }\n      return r;\n    };\n    webidl.sequenceConverter = function(converter) {\n      return (V) => {\n        if (webidl.util.Type(V) !== "Object") {\n          throw webidl.errors.exception({\n            header: "Sequence",\n            message: `Value of type ${webidl.util.Type(V)} is not an Object.`\n          });\n        }\n        const method = V?.[Symbol.iterator]?.();\n        const seq = [];\n        if (method === void 0 || typeof method.next !== "function") {\n          throw webidl.errors.exception({\n            header: "Sequence",\n            message: "Object is not an iterator."\n          });\n        }\n        while (true) {\n          const { done, value } = method.next();\n          if (done) {\n            break;\n          }\n          seq.push(converter(value));\n        }\n        return seq;\n      };\n    };\n    webidl.recordConverter = function(keyConverter, valueConverter) {\n      return (O) => {\n        if (webidl.util.Type(O) !== "Object") {\n          throw webidl.errors.exception({\n            header: "Record",\n            message: `Value of type ${webidl.util.Type(O)} is not an Object.`\n          });\n        }\n        const result = {};\n        if (!types.isProxy(O)) {\n          const keys2 = Object.keys(O);\n          for (const key of keys2) {\n            const typedKey = keyConverter(key);\n            const typedValue = valueConverter(O[key]);\n            result[typedKey] = typedValue;\n          }\n          return result;\n        }\n        const keys = Reflect.ownKeys(O);\n        for (const key of keys) {\n          const desc = Reflect.getOwnPropertyDescriptor(O, key);\n          if (desc?.enumerable) {\n            const typedKey = keyConverter(key);\n            const typedValue = valueConverter(O[key]);\n            result[typedKey] = typedValue;\n          }\n        }\n        return result;\n      };\n    };\n    webidl.interfaceConverter = function(i) {\n      return (V, opts = {}) => {\n        if (opts.strict !== false && !(V instanceof i)) {\n          throw webidl.errors.exception({\n            header: i.name,\n            message: `Expected ${V} to be an instance of ${i.name}.`\n          });\n        }\n        return V;\n      };\n    };\n    webidl.dictionaryConverter = function(converters) {\n      return (dictionary) => {\n        const type = webidl.util.Type(dictionary);\n        const dict = {};\n        if (type === "Null" || type === "Undefined") {\n          return dict;\n        } else if (type !== "Object") {\n          throw webidl.errors.exception({\n            header: "Dictionary",\n            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n          });\n        }\n        for (const options of converters) {\n          const { key, defaultValue, required, converter } = options;\n          if (required === true) {\n            if (!hasOwn(dictionary, key)) {\n              throw webidl.errors.exception({\n                header: "Dictionary",\n                message: `Missing required key "${key}".`\n              });\n            }\n          }\n          let value = dictionary[key];\n          const hasDefault = hasOwn(options, "defaultValue");\n          if (hasDefault && value !== null) {\n            value = value ?? defaultValue;\n          }\n          if (required || hasDefault || value !== void 0) {\n            value = converter(value);\n            if (options.allowedValues && !options.allowedValues.includes(value)) {\n              throw webidl.errors.exception({\n                header: "Dictionary",\n                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`\n              });\n            }\n            dict[key] = value;\n          }\n        }\n        return dict;\n      };\n    };\n    webidl.nullableConverter = function(converter) {\n      return (V) => {\n        if (V === null) {\n          return V;\n        }\n        return converter(V);\n      };\n    };\n    webidl.converters.DOMString = function(V, opts = {}) {\n      if (V === null && opts.legacyNullToEmptyString) {\n        return "";\n      }\n      if (typeof V === "symbol") {\n        throw new TypeError("Could not convert argument of type symbol to string.");\n      }\n      return String(V);\n    };\n    webidl.converters.ByteString = function(V) {\n      const x = webidl.converters.DOMString(V);\n      for (let index = 0; index < x.length; index++) {\n        const charCode = x.charCodeAt(index);\n        if (charCode > 255) {\n          throw new TypeError(\n            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${charCode} which is greater than 255.`\n          );\n        }\n      }\n      return x;\n    };\n    webidl.converters.USVString = toUSVString;\n    webidl.converters.boolean = function(V) {\n      const x = Boolean(V);\n      return x;\n    };\n    webidl.converters.any = function(V) {\n      return V;\n    };\n    webidl.converters["long long"] = function(V) {\n      const x = webidl.util.ConvertToInt(V, 64, "signed");\n      return x;\n    };\n    webidl.converters["unsigned long long"] = function(V) {\n      const x = webidl.util.ConvertToInt(V, 64, "unsigned");\n      return x;\n    };\n    webidl.converters["unsigned long"] = function(V) {\n      const x = webidl.util.ConvertToInt(V, 32, "unsigned");\n      return x;\n    };\n    webidl.converters["unsigned short"] = function(V, opts) {\n      const x = webidl.util.ConvertToInt(V, 16, "