harCodeAt = callBound$9('String.prototype.charCodeAt');
	  var $stringSlice = callBound$9('String.prototype.slice');
	  var advanceStringIndex = function advanceStringIndex(S, index) {
	    var length = S.length;
	    if (index + 1 >= length) {
	      return index + 1;
	    }
	    var first = $charCodeAt(S, index);
	    if (first < 0xD800 || first > 0xDBFF) {
	      return index + 1;
	    }
	    var second = $charCodeAt(S, index + 1);
	    if (second < 0xDC00 || second > 0xDFFF) {
	      return index + 1;
	    }
	    return index + 2;
	  };
	  var getArrayIterator = function getArrayIterator(arraylike) {
	    var i = 0;
	    return {
	      next: function next() {
	        var done = i >= arraylike.length;
	        var value;
	        if (!done) {
	          value = arraylike[i];
	          i += 1;
	        }
	        return {
	          done: done,
	          value: value
	        };
	      }
	    };
	  };
	  var getNonCollectionIterator = function getNonCollectionIterator(iterable, noPrimordialCollections) {
	    if (isArray$1(iterable) || isArguments$1(iterable)) {
	      return getArrayIterator(iterable);
	    }
	    if (isString$1(iterable)) {
	      var i = 0;
	      return {
	        next: function next() {
	          var nextIndex = advanceStringIndex(iterable, i);
	          var value = $stringSlice(iterable, i, nextIndex);
	          i = nextIndex;
	          return {
	            done: nextIndex > iterable.length,
	            value: value
	          };
	        }
	      };
	    }

	    // es6-shim and es-shims' es-map use a string "_es6-shim iterator_" property on different iterables, such as MapIterator.
	    if (noPrimordialCollections && typeof iterable['_es6-shim iterator_'] !== 'undefined') {
	      return iterable['_es6-shim iterator_']();
	    }
	  };
	  if (!$Map && !$Set$1) {
	    // the only language iterables are Array, String, arguments
	    // - Safari <= 6.0
	    // - Chrome < 38
	    // - node < 0.12
	    // - FF < 13
	    // - IE < 11
	    // - Edge < 11

	    esGetIterator.exports = function getIterator(iterable) {
	      if (iterable != null) {
	        return getNonCollectionIterator(iterable, true);
	      }
	    };
	  } else {
	    // either Map or Set are available, but Symbol is not
	    // - es6-shim on an ES5 browser
	    // - Safari 6.2 (maybe 6.1?)
	    // - FF v[13, 36)
	    // - IE 11
	    // - Edge 11
	    // - Safari v[6, 9)

	    var isMap$1 = isMap$2;
	    var isSet$1 = isSet$2;

	    // Firefox >= 27, IE 11, Safari 6.2 - 9, Edge 11, es6-shim in older envs, all have forEach
	    var $mapForEach = callBound$9('Map.prototype.forEach', true);
	    var $setForEach = callBound$9('Set.prototype.forEach', true);
	    if (typeof process === 'undefined' || !process.versions || !process.versions.node) {
	      // "if is not node"

	      // Firefox 17 - 26 has `.iterator()`, whose iterator `.next()` either
	      // returns a value, or throws a StopIteration object. These browsers
	      // do not have any other mechanism for iteration.
	      var $mapIterator = callBound$9('Map.prototype.iterator', true);
	      var $setIterator = callBound$9('Set.prototype.iterator', true);
	    }
	    // Firefox 27-35, and some older es6-shim versions, use a string "@@iterator" property
	    // this returns a proper iterator object, so we should use it instead of forEach.
	    // newer es6-shim versions use a string "_es6-shim iterator_" property.
	    var $mapAtAtIterator = callBound$9('Map.prototype.@@iterator', true) || callBound$9('Map.prototype._es6-shim iterator_', true);
	    var $setAtAtIterator = callBound$9('Set.prototype.@@iterator', true) || callBound$9('Set.prototype._es6-shim iterator_', true);
	    var getCollectionIterator = function getCollectionIterator(iterable) {
	      if (isMap$1(iterable)) {
	        if ($mapIterator) {
	          return getStopIterationIterator($mapIterator(iterable));
	        }
	        if ($mapAtAtIterator) {
	          return $mapAtAtIterator(iterable);
	        }
	        if ($mapForEach) {
	          var entries = [];
	          $mapForEach(iterable, function (v, k) {
	            $arrayPush(entries, [k, v]);
	          });
	          return getArrayIterator(entries);
	        }
	      }
	      if (isSet$1(iterable)) {
	        if ($setIterator) {
	          return getStopIterationIterator($setIterator(iterable));
	        }
	        if ($setAtAtIterator) {
	          return $setAtAtIterator(iterable);
	        }
	        if ($setForEach) {
	          var values = [];
	          $setForEach(iterable, function (v) {
	            $arrayPush(values, v);
	          });
	          return getArrayIterator(values);
	        }
	      }
	    };
	    esGetIterator.exports = function getIterator(iterable) {
	      return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
	    };
	  }
	}

	var numberIsNaN = function (value) {
	  return value !== value;
	};
	var implementation$2 = function is(a, b) {
	  if (a === 0 && b === 0) {
	    return 1 / a === 1 / b;
	  }
	  if (a === b) {
	    return true;
	  }
	  if (numberIsNaN(a) && numberIsNaN(b)) {
	    return true;
	  }
	  return false;
	};

	var implementation$1 = implementation$2;
	var polyfill$1 = function getPolyfill() {
	  return typeof Object.is === 'function' ? Object.is : implementation$1;
	};

	var getPolyfill$1 = polyfill$1;
	var define$1 = defineProperties_1;
	var shim$1 = function shimObjectIs() {
	  var polyfill = getPolyfill$1();
	  define$1(Object, {
	    is: polyfill
	  }, {
	    is: function testObjectIs() {
	      return Object.is !== polyfill;
	    }
	  });
	  return polyfill;
	};

	var define = defineProperties_1;
	var callBind$1 = callBind$5.exports;
	var implementation = implementation$2;
	var getPolyfill = polyfill$1;
	var shim = shim$1;
	var polyfill = callBind$1(getPolyfill(), Object);
	define(polyfill, {
	  getPolyfill: getPolyfill,
	  implementation: implementation,
	  shim: shim
	});
	var objectIs = polyfill;

	var fnToStr = Function.prototype.toString;
	var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
	var badArrayLike;
	var isCallableMarker;
	if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
	  try {
	    badArrayLike = Object.defineProperty({}, 'length', {
	      get: function () {
	        throw isCallableMarker;
	      }
	    });
	    isCallableMarker = {};
	    // eslint-disable-next-line no-throw-literal
	    reflectApply(function () {
	      throw 42;
	    }, null, badArrayLike);
	  } catch (_) {
	    if (_ !== isCallableMarker) {
	      reflectApply = null;
	    }
	  }
	} else {
	  reflectApply = null;
	}
	var constructorRegex = /^\s*class\b/;
	var isES6ClassFn = function isES6ClassFunction(value) {
	  try {
	    var fnStr = fnToStr.call(value);
	    return constructorRegex.test(fnStr);
	  } catch (e) {
	    return false; // not a function
	  }
	};

	var tryFunctionObject = function tryFunctionToStr(value) {
	  try {
	    if (isES6ClassFn(value)) {
	      return false;
	    }
	    fnToStr.call(value);
	    return true;
	  } catch (e) {
	    return false;
	  }
	};
	var toStr$4 = Object.prototype.toString;
	var objectClass = '[object Object]';
	var fnClass = '[object Function]';
	var genClass = '[object GeneratorFunction]';
	var ddaClass = '[object HTMLAllCollection]'; // IE 11
	var ddaClass2 = '[object HTML document.all class]';
	var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
	var hasToStringTag$6 = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

	var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

	var isDDA = function isDocumentDotAll() {
	  return false;
	};
	if (typeof document === 'object') {
	  // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
	  var all = document.all;
	  if (toStr$4.call(all) === toStr$4.call(document.all)) {
	    isDDA = function isDocumentDotAll(value) {
	      /* globals document: false */
	      // in IE 6-8, typeof document.all is "object" and it's truthy
	      if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
	        try {
	          var str = toStr$4.call(value);
	          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
	          || str === objectClass // IE 6-8
	          ) && value('') == null; // eslint-disable-line eqeqeq
	        } catch (e) {/**/}
	      }
	      return false;
	    };
	  }
	}
	var isCallable$1 = reflectApply ? function isCallable(value) {
	  if (isDDA(value)) {
	    return true;
	  }
	  if (!value) {
	    return false;
	  }
	  if (typeof value !== 'function' && typeof value !== 'object') {
	    return false;
	  }
	  try {
	    reflectApply(value, null, badArrayLike);
	  } catch (e) {
	    if (e !== isCallableMarker) {
	      return false;
	    }
	  }
	  return !isES6ClassFn(value) && tryFunctionObject(value);
	} : function isCallable(value) {
	  if (isDDA(value)) {
	    return true;
	  }
	  if (!value) {
	    return false;
	  }
	  if (typeof value !== 'function' && typeof value !== 'object') {
	    return false;
	  }
	  if (hasToStringTag$6) {
	    return tryFunctionObject(value);
	  }
	  if (isES6ClassFn(value)) {
	    return false;
	  }
	  var strClass = toStr$4.call(value);
	  if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
	    return false;
	  }
	  return tryFunctionObject(value);
	};

	var isCallable = isCallable$1;
	var toStr$3 = Object.prototype.toString;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var forEachArray = function forEachArray(array, iterator, receiver) {
	  for (var i = 0, len = array.length; i < len; i++) {
	    if (hasOwnProperty.call(array, i)) {
	      if (receiver == null) {
	        iterator(array[i], i, array);
	      } else {
	        iterator.call(receiver, array[i], i, array);
	      }
	    }
	  }
	};
	var forEachString = function forEachString(string, iterator, receiver) {
	  for (var i = 0, len = string.length; i < len; i++) {
	    // no such thing as a sparse string.
	    if (receiver == null) {
	      iterator(string.charAt(i), i, string);
	    } else {
	      iterator.call(receiver, string.charAt(i), i, string);
	    }
	  }
	};
	var forEachObject = function forEachObject(object, iterator, receiver) {
	  for (var k in object) {
	    if (hasOwnProperty.call(object, k)) {
	      if (receiver == null) {
	        iterator(object[k], k, object);
	      } else {
	        iterator.call(receiver, object[k], k, object);
	      }
	    }
	  }
	};
	var forEach$2 = function forEach(list, iterator, thisArg) {
	  if (!isCallable(iterator)) {
	    throw new TypeError('iterator must be a function');
	  }
	  var receiver;
	  if (arguments.length >= 3) {
	    receiver = thisArg;
	  }
	  if (toStr$3.call(list) === '[object Array]') {
	    forEachArray(list, iterator, receiver);
	  } else if (typeof list === 'string') {
	    forEachString(list, iterator, receiver);
	  } else {
	    forEachObject(list, iterator, receiver);
	  }
	};
	var forEach_1 = forEach$2;

	var possibleNames = ['BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'];
	var g$2 = typeof globalThis === 'undefined' ? commonjsGlobal : globalThis;
	var availableTypedArrays$2 = function availableTypedArrays() {
	  var out = [];
	  for (var i = 0; i < possibleNames.length; i++) {
	    if (typeof g$2[possibleNames[i]] === 'function') {
	      out[out.length] = possibleNames[i];
	    }
	  }
	  return out;
	};

	var GetIntrinsic$3 = getIntrinsic;
	var $gOPD = GetIntrinsic$3('%Object.getOwnPropertyDescriptor%', true);
	if ($gOPD) {
	  try {
	    $gOPD([], 'length');
	  } catch (e) {
	    // IE 8 has a broken gOPD
	    $gOPD = null;
	  }
	}
	var gopd = $gOPD;

	var forEach$1 = forEach_1;
	var availableTypedArrays$1 = availableTypedArrays$2;
	var callBound$8 = callBound$d;
	var $toString$3 = callBound$8('Object.prototype.toString');
	var hasToStringTag$5 = shams();
	var gOPD$2 = gopd;
	var g$1 = typeof globalThis === 'undefined' ? commonjsGlobal : globalThis;
	var typedArrays$1 = availableTypedArrays$1();
	var $indexOf = callBound$8('Array.prototype.indexOf', true) || function indexOf(array, value) {
	  for (var i = 0; i < array.length; i += 1) {
	    if (array[i] === value) {
	      return i;
	    }
	  }
	  return -1;
	};
	var $slice$1 = callBound$8('String.prototype.slice');
	var toStrTags$1 = {};
	var getPrototypeOf$1 = Object.getPrototypeOf; // require('getprototypeof');
	if (hasToStringTag$5 && gOPD$2 && getPrototypeOf$1) {
	  forEach$1(typedArrays$1, function (typedArray) {
	    var arr = new g$1[typedArray]();
	    if (Symbol.toStringTag in arr) {
	      var proto = getPrototypeOf$1(arr);
	      var descriptor = gOPD$2(proto, Symbol.toStringTag);
	      if (!descriptor) {
	        var superProto = getPrototypeOf$1(proto);
	        descriptor = gOPD$2(superProto, Symbol.toStringTag);
	      }
	      toStrTags$1[typedArray] = descriptor.get;
	    }
	  });
	}
	var tryTypedArrays$1 = function tryAllTypedArrays(value) {
	  var anyTrue = false;
	  forEach$1(toStrTags$1, function (getter, typedArray) {
	    if (!anyTrue) {
	      try {
	        anyTrue = getter.call(value) === typedArray;
	      } catch (e) {/**/}
	    }
	  });
	  return anyTrue;
	};
	var isTypedArray$2 = function isTypedArray(value) {
	  if (!value || typeof value !== 'object') {
	    return false;
	  }
	  if (!hasToStringTag$5 || !(Symbol.toStringTag in value)) {
	    var tag = $slice$1($toString$3(value), 8, -1);
	    return $indexOf(typedArrays$1, tag) > -1;
	  }
	  if (!gOPD$2) {
	    return false;
	  }
	  return tryTypedArrays$1(value);
	};

	var callBind = callBind$5.exports;
	var callBound$7 = callBound$d;
	var GetIntrinsic$2 = getIntrinsic;
	var isTypedArray$1 = isTypedArray$2;
	var $ArrayBuffer = GetIntrinsic$2('ArrayBuffer', true);
	var $Float32Array = GetIntrinsic$2('Float32Array', true);
	var $byteLength$2 = callBound$7('ArrayBuffer.prototype.byteLength', true);

	// in node 0.10, ArrayBuffers have no prototype methods, but have an own slot-checking `slice` method
	var abSlice = $ArrayBuffer && !$byteLength$2 && new $ArrayBuffer().slice;
	var $abSlice = abSlice && callBind(abSlice);
	var isArrayBuffer$2 = $byteLength$2 || $abSlice ? function isArrayBuffer(obj) {
	  if (!obj || typeof obj !== 'object') {
	    return false;
	  }
	  try {
	    if ($byteLength$2) {
	      $byteLength$2(obj);
	    } else {
	      $abSlice(obj, 0);
	    }
	    return true;
	  } catch (e) {
	    return false;
	  }
	} : $Float32Array
	// in node 0.8, ArrayBuffers have no prototype or own methods
	? function IsArrayBuffer(obj) {
	  try {
	    return new $Float32Array(obj).buffer === obj && !isTypedArray$1(obj);
	  } catch (e) {
	    return typeof obj === 'object' && e.name === 'RangeError';
	  }
	} : function isArrayBuffer(obj) {
	  // eslint-disable-line no-unused-vars
	  return false;
	};

	var getDay = Date.prototype.getDay;
	var tryDateObject = function tryDateGetDayCall(value) {
	  try {
	    getDay.call(value);
	    return true;
	  } catch (e) {
	    return false;
	  }
	};
	var toStr$2 = Object.prototype.toString;
	var dateClass = '[object Date]';
	var hasToStringTag$4 = shams();
	var isDateObject = function isDateObject(value) {
	  if (typeof value !== 'object' || value === null) {
	    return false;
	  }
	  return hasToStringTag$4 ? tryDateObject(value) : toStr$2.call(value) === dateClass;
	};

	var callBound$6 = callBound$d;
	var hasToStringTag$3 = shams();
	var has;
	var $exec;
	var isRegexMarker;
	var badStringifier;
	if (hasToStringTag$3) {
	  has = callBound$6('Object.prototype.hasOwnProperty');
	  $exec = callBound$6('RegExp.prototype.exec');
	  isRegexMarker = {};
	  var throwRegexMa