      function isFragment(object) {
	        return typeOf(object) === REACT_FRAGMENT_TYPE;
	      }
	      function isLazy(object) {
	        return typeOf(object) === REACT_LAZY_TYPE;
	      }
	      function isMemo(object) {
	        return typeOf(object) === REACT_MEMO_TYPE;
	      }
	      function isPortal(object) {
	        return typeOf(object) === REACT_PORTAL_TYPE;
	      }
	      function isProfiler(object) {
	        return typeOf(object) === REACT_PROFILER_TYPE;
	      }
	      function isStrictMode(object) {
	        return typeOf(object) === REACT_STRICT_MODE_TYPE;
	      }
	      function isSuspense(object) {
	        return typeOf(object) === REACT_SUSPENSE_TYPE;
	      }
	      reactIs_development.ContextConsumer = ContextConsumer;
	      reactIs_development.ContextProvider = ContextProvider;
	      reactIs_development.Element = Element;
	      reactIs_development.ForwardRef = ForwardRef;
	      reactIs_development.Fragment = Fragment;
	      reactIs_development.Lazy = Lazy;
	      reactIs_development.Memo = Memo;
	      reactIs_development.Portal = Portal;
	      reactIs_development.Profiler = Profiler;
	      reactIs_development.StrictMode = StrictMode;
	      reactIs_development.Suspense = Suspense;
	      reactIs_development.isAsyncMode = isAsyncMode;
	      reactIs_development.isConcurrentMode = isConcurrentMode;
	      reactIs_development.isContextConsumer = isContextConsumer;
	      reactIs_development.isContextProvider = isContextProvider;
	      reactIs_development.isElement = isElement;
	      reactIs_development.isForwardRef = isForwardRef;
	      reactIs_development.isFragment = isFragment;
	      reactIs_development.isLazy = isLazy;
	      reactIs_development.isMemo = isMemo;
	      reactIs_development.isPortal = isPortal;
	      reactIs_development.isProfiler = isProfiler;
	      reactIs_development.isStrictMode = isStrictMode;
	      reactIs_development.isSuspense = isSuspense;
	      reactIs_development.isValidElementType = isValidElementType;
	      reactIs_development.typeOf = typeOf;
	    })();
	  }
	  return reactIs_development;
	}

	(function (module) {

	  {
	    module.exports = requireReactIs_development();
	  }
	})(reactIs);

	Object.defineProperty(ReactElement, '__esModule', {
	  value: true
	});
	ReactElement.test = ReactElement.serialize = ReactElement.default = void 0;
	var ReactIs = _interopRequireWildcard(reactIs.exports);
	var _markup$1 = markup;
	function _getRequireWildcardCache(nodeInterop) {
	  if (typeof WeakMap !== 'function') return null;
	  var cacheBabelInterop = new WeakMap();
	  var cacheNodeInterop = new WeakMap();
	  return (_getRequireWildcardCache = function (nodeInterop) {
	    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
	  })(nodeInterop);
	}
	function _interopRequireWildcard(obj, nodeInterop) {
	  if (!nodeInterop && obj && obj.__esModule) {
	    return obj;
	  }
	  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {
	    return {
	      default: obj
	    };
	  }
	  var cache = _getRequireWildcardCache(nodeInterop);
	  if (cache && cache.has(obj)) {
	    return cache.get(obj);
	  }
	  var newObj = {};
	  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
	  for (var key in obj) {
	    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
	      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
	      if (desc && (desc.get || desc.set)) {
	        Object.defineProperty(newObj, key, desc);
	      } else {
	        newObj[key] = obj[key];
	      }
	    }
	  }
	  newObj.default = obj;
	  if (cache) {
	    cache.set(obj, newObj);
	  }
	  return newObj;
	}

	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	// Given element.props.children, or subtree during recursive traversal,
	// return flattened array of children.
	const getChildren = function (arg, children) {
	  if (children === void 0) {
	    children = [];
	  }
	  if (Array.isArray(arg)) {
	    arg.forEach(item => {
	      getChildren(item, children);
	    });
	  } else if (arg != null && arg !== false) {
	    children.push(arg);
	  }
	  return children;
	};
	const getType = element => {
	  const type = element.type;
	  if (typeof type === 'string') {
	    return type;
	  }
	  if (typeof type === 'function') {
	    return type.displayName || type.name || 'Unknown';
	  }
	  if (ReactIs.isFragment(element)) {
	    return 'React.Fragment';
	  }
	  if (ReactIs.isSuspense(element)) {
	    return 'React.Suspense';
	  }
	  if (typeof type === 'object' && type !== null) {
	    if (ReactIs.isContextProvider(element)) {
	      return 'Context.Provider';
	    }
	    if (ReactIs.isContextConsumer(element)) {
	      return 'Context.Consumer';
	    }
	    if (ReactIs.isForwardRef(element)) {
	      if (type.displayName) {
	        return type.displayName;
	      }
	      const functionName = type.render.displayName || type.render.name || '';
	      return functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef';
	    }
	    if (ReactIs.isMemo(element)) {
	      const functionName = type.displayName || type.type.displayName || type.type.name || '';
	      return functionName !== '' ? 'Memo(' + functionName + ')' : 'Memo';
	    }
	  }
	  return 'UNDEFINED';
	};
	const getPropKeys$1 = element => {
	  const {
	    props
	  } = element;
	  return Object.keys(props).filter(key => key !== 'children' && props[key] !== undefined).sort();
	};
	const serialize$1 = (element, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup$1.printElementAsLeaf)(getType(element), config) : (0, _markup$1.printElement)(getType(element), (0, _markup$1.printProps)(getPropKeys$1(element), element.props, config, indentation + config.indent, depth, refs, printer), (0, _markup$1.printChildren)(getChildren(element.props.children), config, indentation + config.indent, depth, refs, printer), config, indentation);
	ReactElement.serialize = serialize$1;
	const test$2 = val => val != null && ReactIs.isElement(val);
	ReactElement.test = test$2;
	const plugin$1 = {
	  serialize: serialize$1,
	  test: test$2
	};
	var _default$2k = plugin$1;
	ReactElement.default = _default$2k;

	var ReactTestComponent = {};

	Object.defineProperty(ReactTestComponent, '__esModule', {
	  value: true
	});
	ReactTestComponent.test = ReactTestComponent.serialize = ReactTestComponent.default = void 0;
	var _markup = markup;
	var global$1 = function () {
	  if (typeof globalThis !== 'undefined') {
	    return globalThis;
	  } else if (typeof global$1 !== 'undefined') {
	    return global$1;
	  } else if (typeof self !== 'undefined') {
	    return self;
	  } else if (typeof window !== 'undefined') {
	    return window;
	  } else {
	    return Function('return this')();
	  }
	}();
	var Symbol$1 = global$1['jest-symbol-do-not-touch'] || global$1.Symbol;
	const testSymbol = typeof Symbol$1 === 'function' && Symbol$1.for ? Symbol$1.for('react.test.json') : 0xea71357;
	const getPropKeys = object => {
	  const {
	    props
	  } = object;
	  return props ? Object.keys(props).filter(key => props[key] !== undefined).sort() : [];
	};
	const serialize = (object, config, indentation, depth, refs, printer) => ++depth > config.maxDepth ? (0, _markup.printElementAsLeaf)(object.type, config) : (0, _markup.printElement)(object.type, object.props ? (0, _markup.printProps)(getPropKeys(object), object.props, config, indentation + config.indent, depth, refs, printer) : '', object.children ? (0, _markup.printChildren)(object.children, config, indentation + config.indent, depth, refs, printer) : '', config, indentation);
	ReactTestComponent.serialize = serialize;
	const test$1 = val => val && val.$$typeof === testSymbol;
	ReactTestComponent.test = test$1;
	const plugin = {
	  serialize,
	  test: test$1
	};
	var _default$2j = plugin;
	ReactTestComponent.default = _default$2j;

	Object.defineProperty(build, '__esModule', {
	  value: true
	});
	var default_1 = build.default = DEFAULT_OPTIONS_1 = build.DEFAULT_OPTIONS = void 0;
	var format_1 = build.format = format;
	var plugins_1 = build.plugins = void 0;
	var _ansiStyles = _interopRequireDefault$b(ansiStyles.exports);
	var _collections = collections;
	var _AsymmetricMatcher = _interopRequireDefault$b(AsymmetricMatcher);
	var _ConvertAnsi = _interopRequireDefault$b(ConvertAnsi);
	var _DOMCollection = _interopRequireDefault$b(DOMCollection$1);
	var _DOMElement = _interopRequireDefault$b(DOMElement);
	var _Immutable = _interopRequireDefault$b(Immutable);
	var _ReactElement = _interopRequireDefault$b(ReactElement);
	var _ReactTestComponent = _interopRequireDefault$b(ReactTestComponent);
	function _interopRequireDefault$b(obj) {
	  return obj && obj.__esModule ? obj : {
	    default: obj
	  };
	}

	/**
	 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	/* eslint-disable local/ban-types-eventually */
	const toString$1 = Object.prototype.toString;
	const toISOString = Date.prototype.toISOString;
	const errorToString = Error.prototype.toString;
	const regExpToString = RegExp.prototype.toString;
	/**
	 * Explicitly comparing typeof constructor to function avoids undefined as name
	 * when mock identity-obj-proxy returns the key as the value for any key.
	 */

	const getConstructorName = val => typeof val.constructor === 'function' && val.constructor.name || 'Object';
	/* global window */

	/** Is val is equal to global window object? Works even if it does not exist :) */

	const isWindow = val => typeof window !== 'undefined' && val === window;
	const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
	const NEWLINE_REGEXP = /\n/gi;
	class PrettyFormatPluginError extends Error {
	  constructor(message, stack) {
	    super(message);
	    this.stack = stack;
	    this.name = this.constructor.name;
	  }
	}
	function isToStringedArrayType(toStringed) {
	  return toStringed === '[object Array]' || toStringed === '[object ArrayBuffer]' || toStringed === '[object DataView]' || toStringed === '[object Float32Array]' || toStringed === '[object Float64Array]' || toStringed === '[object Int8Array]' || toStringed === '[object Int16Array]' || toStringed === '[object Int32Array]' || toStringed === '[object Uint8Array]' || toStringed === '[object Uint8ClampedArray]' || toStringed === '[object Uint16Array]' || toStringed === '[object Uint32Array]';
	}
	function printNumber(val) {
	  return Object.is(val, -0) ? '-0' : String(val);
	}
	function printBigInt(val) {
	  return String(val + "n");
	}
	function printFunction(val, printFunctionName) {
	  if (!printFunctionName) {
	    return '[Function]';
	  }
	  return '[Function ' + (val.name || 'anonymous') + ']';
	}
	function printSymbol(val) {
	  return String(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
	}
	function printError(val) {
	  return '[' + errorToString.call(val) + ']';
	}
	/**
	 * The first port of call for printing an object, handles most of the
	 * data-types in JS.
	 */

	function printBasicValue(val, printFunctionName, escapeRegex, escapeString) {
	  if (val === true || val === false) {
	    return '' + val;
	  }
	  if (val === undefined) {
	    return 'undefined';
	  }
	  if (val === null) {
	    return 'null';
	  }
	  const typeOf = typeof val;
	  if (typeOf === 'number') {
	    return printNumber(val);
	  }
	  if (typeOf === 'bigint') {
	    return printBigInt(val);
	  }
	  if (typeOf === 'string') {
	    if (escapeString) {
	      return '"' + val.replace(/"|\\/g, '\\$&') + '"';
	    }
	    return '"' + val + '"';
	  }
	  if (typeOf === 'function') {
	    return printFunction(val, printFunctionName);
	  }
	  if (typeOf === 'symbol') {
	    return printSymbol(val);
	  }
	  const toStringed = toString$1.call(val);
	  if (toStringed === '[object WeakMap]') {
	    return 'WeakMap {}';
	  }
	  if (toStringed === '[object WeakSet]') {
	    return 'WeakSet {}';
	  }
	  if (toStringed === '[object Function]' || toStringed === '[object GeneratorFunction]') {
	    return printFunction(val, printFunctionName);
	  }
	  if (toStringed === '[object Symbol]') {
	    return printSymbol(val);