 || typeof value !== 'object') {
	    return false;
	  }
	  var descriptor = gOPD$1(value, 'lastIndex');
	  var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
	  if (!hasLastIndexDataProperty) {
	    return false;
	  }
	  try {
	    $exec(value, badStringifier);
	  } catch (e) {
	    return e === isRegexMarker;
	  }
	} : function isRegex(value) {
	  // In older browsers, typeof regex incorrectly returns 'function'
	  if (!value || typeof value !== 'object' && typeof value !== 'function') {
	    return false;
	  }
	  return $toString$2(value) === regexClass;
	};

	var callBound$5 = callBound$d;
	var $byteLength$1 = callBound$5('SharedArrayBuffer.prototype.byteLength', true);
	var isSharedArrayBuffer$1 = $byteLength$1 ? function isSharedArrayBuffer(obj) {
	  if (!obj || typeof obj !== 'object') {
	    return false;
	  }
	  try {
	    $byteLength$1(obj);
	    return true;
	  } catch (e) {
	    return false;
	  }
	} : function isSharedArrayBuffer(obj) {
	  // eslint-disable-line no-unused-vars
	  return false;
	};

	var numToStr = Number.prototype.toString;
	var tryNumberObject = function tryNumberObject(value) {
	  try {
	    numToStr.call(value);
	    return true;
	  } catch (e) {
	    return false;
	  }
	};
	var toStr$1 = Object.prototype.toString;
	var numClass = '[object Number]';
	var hasToStringTag$2 = shams();
	var isNumberObject = function isNumberObject(value) {
	  if (typeof value === 'number') {
	    return true;
	  }
	  if (typeof value !== 'object') {
	    return false;
	  }
	  return hasToStringTag$2 ? tryNumberObject(value) : toStr$1.call(value) === numClass;
	};

	var callBound$4 = callBound$d;
	var $boolToStr = callBound$4('Boolean.prototype.toString');
	var $toString$1 = callBound$4('Object.prototype.toString');
	var tryBooleanObject = function booleanBrandCheck(value) {
	  try {
	    $boolToStr(value);
	    return true;
	  } catch (e) {
	    return false;
	  }
	};
	var boolClass = '[object Boolean]';
	var hasToStringTag$1 = shams();
	var isBooleanObject = function isBoolean(value) {
	  if (typeof value === 'boolean') {
	    return true;
	  }
	  if (value === null || typeof value !== 'object') {
	    return false;
	  }
	  return hasToStringTag$1 && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString$1(value) === boolClass;
	};

	var isSymbol$1 = {exports: {}};

	var toStr = Object.prototype.toString;
	var hasSymbols = hasSymbols$5();
	if (hasSymbols) {
	  var symToStr = Symbol.prototype.toString;
	  var symStringRegex = /^Symbol\(.*\)$/;
	  var isSymbolObject = function isRealSymbolObject(value) {
	    if (typeof value.valueOf() !== 'symbol') {
	      return false;
	    }
	    return symStringRegex.test(symToStr.call(value));
	  };
	  isSymbol$1.exports = function isSymbol(value) {
	    if (typeof value === 'symbol') {
	      return true;
	    }
	    if (toStr.call(value) !== '[object Symbol]') {
	      return false;
	    }
	    try {
	      return isSymbolObject(value);
	    } catch (e) {
	      return false;
	    }
	  };
	} else {
	  isSymbol$1.exports = function isSymbol(value) {
	    // this environment does not support Symbols.
	    return false ;
	  };
	}

	var isBigint = {exports: {}};

	var $BigInt = typeof BigInt !== 'undefined' && BigInt;
	var hasBigints = function hasNativeBigInts() {
	  return typeof $BigInt === 'function' && typeof BigInt === 'function' && typeof $BigInt(42) === 'bigint' // eslint-disable-line no-magic-numbers
	  && typeof BigInt(42) === 'bigint'; // eslint-disable-line no-magic-numbers
	};

	var hasBigInts = hasBigints();
	if (hasBigInts) {
	  var bigIntValueOf = BigInt.prototype.valueOf;
	  var tryBigInt = function tryBigIntObject(value) {
	    try {
	      bigIntValueOf.call(value);
	      return true;
	    } catch (e) {}
	    return false;
	  };
	  isBigint.exports = function isBigInt(value) {
	    if (value === null || typeof value === 'undefined' || typeof value === 'boolean' || typeof value === 'string' || typeof value === 'number' || typeof value === 'symbol' || typeof value === 'function') {
	      return false;
	    }
	    if (typeof value === 'bigint') {
	      return true;
	    }
	    return tryBigInt(value);
	  };
	} else {
	  isBigint.exports = function isBigInt(value) {
	    return false ;
	  };
	}

	var isString = isString$2;
	var isNumber = isNumberObject;
	var isBoolean = isBooleanObject;
	var isSymbol = isSymbol$1.exports;
	var isBigInt = isBigint.exports;

	// eslint-disable-next-line consistent-return
	var whichBoxedPrimitive$1 = function whichBoxedPrimitive(value) {
	  // eslint-disable-next-line eqeqeq
	  if (value == null || typeof value !== 'object' && typeof value !== 'function') {
	    return null;
	  }
	  if (isString(value)) {
	    return 'String';
	  }
	  if (isNumber(value)) {
	    return 'Number';
	  }
	  if (isBoolean(value)) {
	    return 'Boolean';
	  }
	  if (isSymbol(value)) {
	    return 'Symbol';
	  }
	  if (isBigInt(value)) {
	    return 'BigInt';
	  }
	};

	var $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;
	var $WeakSet$1 = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;
	var exported;
	if (!$WeakMap) {
	  // eslint-disable-next-line no-unused-vars
	  exported = function isWeakMap(x) {
	    // `WeakMap` is not present in this environment.
	    return false;
	  };
	}
	var $mapHas$2 = $WeakMap ? $WeakMap.prototype.has : null;
	var $setHas$2 = $WeakSet$1 ? $WeakSet$1.prototype.has : null;
	if (!exported && !$mapHas$2) {
	  // eslint-disable-next-line no-unused-vars
	  exported = function isWeakMap(x) {
	    // `WeakMap` does not have a `has` method
	    return false;
	  };
	}
	var isWeakmap = exported || function isWeakMap(x) {
	  if (!x || typeof x !== 'object') {
	    return false;
	  }
	  try {
	    $mapHas$2.call(x, $mapHas$2);
	    if ($setHas$2) {
	      try {
	        $setHas$2.call(x, $setHas$2);
	      } catch (e) {
	        return true;
	      }
	    }
	    return x instanceof $WeakMap; // core-js workaround, pre-v3
	  } catch (e) {}
	  return false;
	};

	var isWeakset = {exports: {}};

	var GetIntrinsic$1 = getIntrinsic;
	var callBound$3 = callBound$d;
	var $WeakSet = GetIntrinsic$1('%WeakSet%', true);
	var $setHas$1 = callBound$3('WeakSet.prototype.has', true);
	if ($setHas$1) {
	  var $mapHas$1 = callBound$3('WeakMap.prototype.has', true);
	  isWeakset.exports = function isWeakSet(x) {
	    if (!x || typeof x !== 'object') {
	      return false;
	    }
	    try {
	      $setHas$1(x, $setHas$1);
	      if ($mapHas$1) {
	        try {
	          $mapHas$1(x, $mapHas$1);
	        } catch (e) {
	          return true;
	        }
	      }
	      return x instanceof $WeakSet; // core-js workaround, pre-v3
	    } catch (e) {}
	    return false;
	  };
	} else {
	  // eslint-disable-next-line no-unused-vars
	  isWeakset.exports = function isWeakSet(x) {
	    // `WeakSet` does not exist, or does not have a `has` method
	    return false;
	  };
	}

	var isMap = isMap$2;
	var isSet = isSet$2;
	var isWeakMap = isWeakmap;
	var isWeakSet = isWeakset.exports;
	var whichCollection$1 = function whichCollection(value) {
	  if (value && typeof value === 'object') {
	    if (isMap(value)) {
	      return 'Map';
	    }
	    if (isSet(value)) {
	      return 'Set';
	    }
	    if (isWeakMap(value)) {
	      return 'WeakMap';
	    }
	    if (isWeakSet(value)) {
	      return 'WeakSet';
	    }
	  }
	  return false;
	};

	var forEach = forEach_1;
	var availableTypedArrays = availableTypedArrays$2;
	var callBound$2 = callBound$d;
	var gOPD = gopd;
	var $toString = callBound$2('Object.prototype.toString');
	var hasToStringTag = shams();
	var g = typeof globalThis === 'undefined' ? commonjsGlobal : globalThis;
	var typedArrays = availableTypedArrays();
	var $slice = callBound$2('String.prototype.slice');
	var toStrTags = {};
	var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');
	if (hasToStringTag && gOPD && getPrototypeOf) {
	  forEach(typedArrays, function (typedArray) {
	    if (typeof g[typedArray] === 'function') {
	      var arr = new g[typedArray]();
	      if (Symbol.toStringTag in arr) {
	        var proto = getPrototypeOf(arr);
	        var descriptor = gOPD(proto, Symbol.toStringTag);
	        if (!descriptor) {
	          var superProto = getPrototypeOf(proto);
	          descriptor = gOPD(superProto, Symbol.toStringTag);
	        }
	        toStrTags[typedArray] = descriptor.get;
	      }
	    }
	  });
	}
	var tryTypedArrays = function tryAllTypedArrays(value) {
	  var foundName = false;
	  forEach(toStrTags, function (getter, typedArray) {
	    if (!foundName) {
	      try {
	        var name = getter.call(value);
	        if (name === typedArray) {
	          foundName = name;
	        }
	      } catch (e) {}
	    }
	  });
	  return foundName;
	};
	var isTypedArray = isTypedArray$2;
	var whichTypedArray$1 = function whichTypedArray(value) {
	  if (!isTypedArray(value)) {
	    return false;
	  }
	  if (!hasToStringTag || !(Symbol.toStringTag in value)) {
	    return $slice($toString(value), 8, -1);
	  }
	  return tryTypedArrays(value);
	};

	var callBound$1 = callBound$d;
	var $byteLength = callBound$1('ArrayBuffer.prototype.byteLength', true);
	var isArrayBuffer$1 = isArrayBuffer$2;
	var arrayBufferByteLength = function byteLength(ab) {
	  if (!isArrayBuffer$1(ab)) {
	    return NaN;
	  }
	  return $byteLength ? $byteLength(ab) : ab.byteLength;
	}; // in node < 0.11, byteLength is an own nonconfigurable property

	var assign = object_assign;
	var callBound = callBound$d;
	var flags = regexp_prototype_flags;
	var GetIntrinsic = getIntrinsic;
	var getIterator = esGetIterator.exports;
	var getSideChannel = sideChannel;
	var is = objectIs;
	var isArguments = isArguments$2;
	var isArray = isarray;
	var isArrayBuffer = isArrayBuffer$2;
	var isDate = isDateObject;
	var isRegex = isRegex$1;
	var isSharedArrayBuffer = isSharedArrayBuffer$1;
	var objectKeys = objectKeys$2;
	var whichBoxedPrimitive = whichBoxedPrimitive$1;
	var whichCollection = whichCollection$1;
	var whichTypedArray = whichTypedArray$1;
	var byteLength = arrayBufferByteLength;
	var sabByteLength = callBound('SharedArrayBuffer.prototype.byteLength', true);
	var $getTime = callBound('Date.prototype.getTime');
	var gPO = Object.getPrototypeOf;
	var $objToString = callBound('Object.prototype.toString');
	var $Set = GetIntrinsic('%Set%', true);
	var $mapHas = callBound('Map.prototype.has', true);
	var $mapGet = callBound('Map.prototype.get', true);
	var $mapSize = callBound('Map.prototype.size', true);
	var $setAdd = callBound('Set.prototype.add', true);
	var $setDelete = callBound('Set.prototype.delete', true);
	var $setHas = callBound('Set.prototype.has', true);
	var $setSize = callBound('Set.prototype.size', true);

	// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414
	function setHasEqualElement(set, val1, opts, channel) {
	  var i = getIterator(set);
	  var result;
	  while ((result = i.next()) && !result.done) {
	    if (internalDeepEqual(val1, result.value, opts, channel)) {
	      // eslint-disable-line no-use-before-define
	      // Remove the matching element to make sure we do not check that again.
	      $setDelete(set, result.value);
	      return true;
	    }
	  }
	  return false;
	}

	// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439
	function findLooseMatchingPrimitives(prim) {
	  if (typeof prim === 'undefined') {
	    return null;
	  }
	  if (typeof prim === 'object') {
	    // Only pass in null as object!
	    return void 0;
	  }
	  if (typeof prim === 'symbol') {
	    return false;
	  }
	  if (typeof prim === 'string' || typeof prim === 'number') {
	    // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.
	    return +prim === +prim; // eslint-disable-line no-implicit-coercion
	  }

	  return true;
	}

	// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460
	function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {
	  var altValue = findLooseMatchingPrimitives(prim);
	  if (altValue != null) {
	    return altValue;
	  }
	  var curB = $mapGet(b, altValue);
	  var looseOpts = assign({}, opts, {
	    strict: false
	  });
	  if (typeof curB === 'undefined' && !$mapHas(b, altValue)
	  // eslint-disable-next-line no-use-before-define
	  || !internalDeepEqual(item, curB, looseOpts, channel)) {
	    return false;
	  }
	  // eslint-disable-next-line no-use-before-define
	  return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
	}

	// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447
	function setMightHaveLoosePrim(a, b, prim) {
	  var altValue = findLooseMatchingPrimitives(prim);
	  if (altValue != null) {
	    return altValue;
	  }
	  return $setHas(b, altValue) && !$setHas(a, altValue);
	}

	// taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533
	function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
	  var i = getIterator(set);
	  var result;
	  var key2;
	  while ((result = i.next()) && !result.done) {
	    key2 = result.value;
	    if (
	    // eslint-disable-next-line no-use-before-define
	    internalDeepEqual(key1, key2, opts, channel)
	    // eslint-disable-next-line no-use-before-define
	    && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)) {
	      $setDelete(set, key2);
	      return true;
	    }
	  }
	  return false;
	}
	function internalDeepEqual(actual, expected, options, channel) {
	  var opts = options || {};

	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (opts.strict ? is(actual, expected) : actual === expected) {
	    return true;
	  }
	  var actualBoxed = whichBoxedPrimitive(actual);
	  var expectedBoxed = whichBoxedPrimitive(expected);
	  if (actualBoxed !== expectedBoxed) {
	    return false;
	  }

	  // 7.3. Other pairs that do not both pass typeof 